#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def end_apply(self):
        pass

    def get_active_producers(self):
        pass

    def get_resource_limits(self, account):
        """
        Parameters:
         - account

        """
        pass

    def set_resource_limits(self, account, ram_bytes, net_weight, cpu_weight):
        """
        Parameters:
         - account
         - ram_bytes
         - net_weight
         - cpu_weight

        """
        pass

    def set_proposed_producers(self, producer_data):
        """
        Parameters:
         - producer_data

        """
        pass

    def set_proposed_producers_ex(self, producer_data_format, producer_data):
        """
        Parameters:
         - producer_data_format
         - producer_data

        """
        pass

    def is_privileged(self, account):
        """
        Parameters:
         - account

        """
        pass

    def set_privileged(self, account, is_priv):
        """
        Parameters:
         - account
         - is_priv

        """
        pass

    def set_blockchain_parameters_packed(self, data):
        """
        Parameters:
         - data

        """
        pass

    def get_blockchain_parameters_packed(self):
        pass

    def preactivate_feature(self, feature_digest):
        """
        Parameters:
         - feature_digest

        """
        pass

    def check_transaction_authorization(self, trx_data, pubkeys_data, perms_data):
        """
        Parameters:
         - trx_data
         - pubkeys_data
         - perms_data

        """
        pass

    def check_permission_authorization(self, account, permission, pubkeys_data, perms_data, delay_us):
        """
        Parameters:
         - account
         - permission
         - pubkeys_data
         - perms_data
         - delay_us

        """
        pass

    def get_permission_last_used(self, account, permission):
        """
        Parameters:
         - account
         - permission

        """
        pass

    def get_account_creation_time(self, account):
        """
        Parameters:
         - account

        """
        pass

    def prints(self, cstr):
        """
        Parameters:
         - cstr

        """
        pass

    def prints_l(self, cstr):
        """
        Parameters:
         - cstr

        """
        pass

    def printi(self, n):
        """
        Parameters:
         - n

        """
        pass

    def printui(self, n):
        """
        Parameters:
         - n

        """
        pass

    def printi128(self, value):
        """
        Parameters:
         - value

        """
        pass

    def printui128(self, value):
        """
        Parameters:
         - value

        """
        pass

    def printsf(self, value):
        """
        Parameters:
         - value

        """
        pass

    def printdf(self, value):
        """
        Parameters:
         - value

        """
        pass

    def printqf(self, value):
        """
        Parameters:
         - value

        """
        pass

    def printn(self, name):
        """
        Parameters:
         - name

        """
        pass

    def printhex(self, data):
        """
        Parameters:
         - data

        """
        pass

    def action_data_size(self):
        pass

    def read_action_data(self):
        pass

    def require_recipient(self, name):
        """
        Parameters:
         - name

        """
        pass

    def require_auth(self, name):
        """
        Parameters:
         - name

        """
        pass

    def has_auth(self, name):
        """
        Parameters:
         - name

        """
        pass

    def require_auth2(self, name, permission):
        """
        Parameters:
         - name
         - permission

        """
        pass

    def is_account(self, name):
        """
        Parameters:
         - name

        """
        pass

    def send_inline(self, serialized_action):
        """
        Parameters:
         - serialized_action

        """
        pass

    def send_context_free_inline(self, serialized_data):
        """
        Parameters:
         - serialized_data

        """
        pass

    def publication_time(self):
        pass

    def current_receiver(self):
        pass

    def eosio_assert(self, test, msg):
        """
        Parameters:
         - test
         - msg

        """
        pass

    def eosio_assert_message(self, test, msg):
        """
        Parameters:
         - test
         - msg

        """
        pass

    def eosio_assert_code(self, test, code):
        """
        Parameters:
         - test
         - code

        """
        pass

    def eosio_exit(self, code):
        """
        Parameters:
         - code

        """
        pass

    def current_time(self):
        pass

    def is_feature_activated(self, feature_digest):
        """
        Parameters:
         - feature_digest

        """
        pass

    def get_sender(self):
        pass

    def assert_sha256(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        pass

    def assert_sha1(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        pass

    def assert_sha512(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        pass

    def assert_ripemd160(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        pass

    def sha256(self, data):
        """
        Parameters:
         - data

        """
        pass

    def sha1(self, data):
        """
        Parameters:
         - data

        """
        pass

    def sha512(self, data):
        """
        Parameters:
         - data

        """
        pass

    def ripemd160(self, data):
        """
        Parameters:
         - data

        """
        pass

    def recover_key(self, digest, sig):
        """
        Parameters:
         - digest
         - sig

        """
        pass

    def assert_recover_key(self, digest, sig, pub):
        """
        Parameters:
         - digest
         - sig
         - pub

        """
        pass

    def send_deferred(self, sender_id, payer, serialized_transaction, replace_existing):
        """
        Parameters:
         - sender_id
         - payer
         - serialized_transaction
         - replace_existing

        """
        pass

    def cancel_deferred(self, sender_id):
        """
        Parameters:
         - sender_id

        """
        pass

    def read_transaction(self):
        pass

    def transaction_size(self):
        pass

    def tapos_block_num(self):
        pass

    def tapos_block_prefix(self):
        pass

    def expiration(self):
        pass

    def get_action(self, _type, index):
        """
        Parameters:
         - _type
         - index

        """
        pass

    def get_context_free_data(self, index):
        """
        Parameters:
         - index

        """
        pass

    def db_store_i64(self, scope, table, payer, id, data):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - data

        """
        pass

    def db_update_i64(self, iterator, payer, data):
        """
        Parameters:
         - iterator
         - payer
         - data

        """
        pass

    def db_remove_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_get_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_next_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_previous_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_find_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        pass

    def db_lowerbound_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        pass

    def db_upperbound_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        pass

    def db_end_i64(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def db_idx64_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        pass

    def db_idx64_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        pass

    def db_idx64_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx64_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx64_previous(self, iteratory):
        """
        Parameters:
         - iteratory

        """
        pass

    def db_idx64_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        pass

    def db_idx64_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        pass

    def db_idx64_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx64_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx64_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def db_idx128_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        pass

    def db_idx128_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        pass

    def db_idx128_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx128_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx128_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx128_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        pass

    def db_idx128_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        pass

    def db_idx128_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx128_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx128_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def db_idx256_store(self, scope, table, payer, id, data):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - data

        """
        pass

    def db_idx256_update(self, iterator, payer, data):
        """
        Parameters:
         - iterator
         - payer
         - data

        """
        pass

    def db_idx256_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx256_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx256_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx256_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        pass

    def db_idx256_find_secondary(self, code, scope, table, data):
        """
        Parameters:
         - code
         - scope
         - table
         - data

        """
        pass

    def db_idx256_lowerbound(self, code, scope, table, data, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - data
         - primary

        """
        pass

    def db_idx256_upperbound(self, code, scope, table, data, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - data
         - primary

        """
        pass

    def db_idx256_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def db_idx_double_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        pass

    def db_idx_double_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        pass

    def db_idx_double_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_double_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_double_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_double_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        pass

    def db_idx_double_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        pass

    def db_idx_double_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx_double_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx_double_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def db_idx_long_double_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        pass

    def db_idx_long_double_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        pass

    def db_idx_long_double_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_long_double_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_long_double_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        pass

    def db_idx_long_double_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        pass

    def db_idx_long_double_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        pass

    def db_idx_long_double_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx_long_double_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        pass

    def db_idx_long_double_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        pass

    def set_action_return_value(self, data):
        """
        Parameters:
         - data

        """
        pass

    def get_code_hash(self, account, struct_version):
        """
        Parameters:
         - account
         - struct_version

        """
        pass

    def get_block_num(self):
        pass

    def sha3(self, data, keccak):
        """
        Parameters:
         - data
         - keccak

        """
        pass

    def blake2_f(self, rounds, state, msg, t0_offset, t1_offset, final):
        """
        Parameters:
         - rounds
         - state
         - msg
         - t0_offset
         - t1_offset
         - final

        """
        pass

    def k1_recover(self, sig, dig):
        """
        Parameters:
         - sig
         - dig

        """
        pass

    def alt_bn128_add(self, op1, op2):
        """
        Parameters:
         - op1
         - op2

        """
        pass

    def alt_bn128_mul(self, g1, scalar):
        """
        Parameters:
         - g1
         - scalar

        """
        pass

    def alt_bn128_pair(self, pairs):
        """
        Parameters:
         - pairs

        """
        pass

    def mod_exp(self, base, exp, mod):
        """
        Parameters:
         - base
         - exp
         - mod

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def end_apply(self):
        self.send_end_apply()
        return self.recv_end_apply()

    def send_end_apply(self):
        self._oprot.writeMessageBegin('end_apply', TMessageType.CALL, self._seqid)
        args = end_apply_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_apply(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_apply_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "end_apply failed: unknown result")

    def get_active_producers(self):
        self.send_get_active_producers()
        return self.recv_get_active_producers()

    def send_get_active_producers(self):
        self._oprot.writeMessageBegin('get_active_producers', TMessageType.CALL, self._seqid)
        args = get_active_producers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_active_producers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_active_producers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_active_producers failed: unknown result")

    def get_resource_limits(self, account):
        """
        Parameters:
         - account

        """
        self.send_get_resource_limits(account)
        return self.recv_get_resource_limits()

    def send_get_resource_limits(self, account):
        self._oprot.writeMessageBegin('get_resource_limits', TMessageType.CALL, self._seqid)
        args = get_resource_limits_args()
        args.account = account
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_resource_limits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_resource_limits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_resource_limits failed: unknown result")

    def set_resource_limits(self, account, ram_bytes, net_weight, cpu_weight):
        """
        Parameters:
         - account
         - ram_bytes
         - net_weight
         - cpu_weight

        """
        self.send_set_resource_limits(account, ram_bytes, net_weight, cpu_weight)
        self.recv_set_resource_limits()

    def send_set_resource_limits(self, account, ram_bytes, net_weight, cpu_weight):
        self._oprot.writeMessageBegin('set_resource_limits', TMessageType.CALL, self._seqid)
        args = set_resource_limits_args()
        args.account = account
        args.ram_bytes = ram_bytes
        args.net_weight = net_weight
        args.cpu_weight = cpu_weight
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_resource_limits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_resource_limits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def set_proposed_producers(self, producer_data):
        """
        Parameters:
         - producer_data

        """
        self.send_set_proposed_producers(producer_data)
        return self.recv_set_proposed_producers()

    def send_set_proposed_producers(self, producer_data):
        self._oprot.writeMessageBegin('set_proposed_producers', TMessageType.CALL, self._seqid)
        args = set_proposed_producers_args()
        args.producer_data = producer_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_proposed_producers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_proposed_producers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_proposed_producers failed: unknown result")

    def set_proposed_producers_ex(self, producer_data_format, producer_data):
        """
        Parameters:
         - producer_data_format
         - producer_data

        """
        self.send_set_proposed_producers_ex(producer_data_format, producer_data)
        return self.recv_set_proposed_producers_ex()

    def send_set_proposed_producers_ex(self, producer_data_format, producer_data):
        self._oprot.writeMessageBegin('set_proposed_producers_ex', TMessageType.CALL, self._seqid)
        args = set_proposed_producers_ex_args()
        args.producer_data_format = producer_data_format
        args.producer_data = producer_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_proposed_producers_ex(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_proposed_producers_ex_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_proposed_producers_ex failed: unknown result")

    def is_privileged(self, account):
        """
        Parameters:
         - account

        """
        self.send_is_privileged(account)
        return self.recv_is_privileged()

    def send_is_privileged(self, account):
        self._oprot.writeMessageBegin('is_privileged', TMessageType.CALL, self._seqid)
        args = is_privileged_args()
        args.account = account
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_privileged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_privileged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_privileged failed: unknown result")

    def set_privileged(self, account, is_priv):
        """
        Parameters:
         - account
         - is_priv

        """
        self.send_set_privileged(account, is_priv)
        self.recv_set_privileged()

    def send_set_privileged(self, account, is_priv):
        self._oprot.writeMessageBegin('set_privileged', TMessageType.CALL, self._seqid)
        args = set_privileged_args()
        args.account = account
        args.is_priv = is_priv
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_privileged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_privileged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def set_blockchain_parameters_packed(self, data):
        """
        Parameters:
         - data

        """
        self.send_set_blockchain_parameters_packed(data)
        self.recv_set_blockchain_parameters_packed()

    def send_set_blockchain_parameters_packed(self, data):
        self._oprot.writeMessageBegin('set_blockchain_parameters_packed', TMessageType.CALL, self._seqid)
        args = set_blockchain_parameters_packed_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_blockchain_parameters_packed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_blockchain_parameters_packed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_blockchain_parameters_packed(self):
        self.send_get_blockchain_parameters_packed()
        return self.recv_get_blockchain_parameters_packed()

    def send_get_blockchain_parameters_packed(self):
        self._oprot.writeMessageBegin('get_blockchain_parameters_packed', TMessageType.CALL, self._seqid)
        args = get_blockchain_parameters_packed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_blockchain_parameters_packed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_blockchain_parameters_packed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_blockchain_parameters_packed failed: unknown result")

    def preactivate_feature(self, feature_digest):
        """
        Parameters:
         - feature_digest

        """
        self.send_preactivate_feature(feature_digest)
        self.recv_preactivate_feature()

    def send_preactivate_feature(self, feature_digest):
        self._oprot.writeMessageBegin('preactivate_feature', TMessageType.CALL, self._seqid)
        args = preactivate_feature_args()
        args.feature_digest = feature_digest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_preactivate_feature(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = preactivate_feature_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def check_transaction_authorization(self, trx_data, pubkeys_data, perms_data):
        """
        Parameters:
         - trx_data
         - pubkeys_data
         - perms_data

        """
        self.send_check_transaction_authorization(trx_data, pubkeys_data, perms_data)
        return self.recv_check_transaction_authorization()

    def send_check_transaction_authorization(self, trx_data, pubkeys_data, perms_data):
        self._oprot.writeMessageBegin('check_transaction_authorization', TMessageType.CALL, self._seqid)
        args = check_transaction_authorization_args()
        args.trx_data = trx_data
        args.pubkeys_data = pubkeys_data
        args.perms_data = perms_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_transaction_authorization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_transaction_authorization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_transaction_authorization failed: unknown result")

    def check_permission_authorization(self, account, permission, pubkeys_data, perms_data, delay_us):
        """
        Parameters:
         - account
         - permission
         - pubkeys_data
         - perms_data
         - delay_us

        """
        self.send_check_permission_authorization(account, permission, pubkeys_data, perms_data, delay_us)
        return self.recv_check_permission_authorization()

    def send_check_permission_authorization(self, account, permission, pubkeys_data, perms_data, delay_us):
        self._oprot.writeMessageBegin('check_permission_authorization', TMessageType.CALL, self._seqid)
        args = check_permission_authorization_args()
        args.account = account
        args.permission = permission
        args.pubkeys_data = pubkeys_data
        args.perms_data = perms_data
        args.delay_us = delay_us
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_permission_authorization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_permission_authorization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_permission_authorization failed: unknown result")

    def get_permission_last_used(self, account, permission):
        """
        Parameters:
         - account
         - permission

        """
        self.send_get_permission_last_used(account, permission)
        return self.recv_get_permission_last_used()

    def send_get_permission_last_used(self, account, permission):
        self._oprot.writeMessageBegin('get_permission_last_used', TMessageType.CALL, self._seqid)
        args = get_permission_last_used_args()
        args.account = account
        args.permission = permission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_permission_last_used(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_permission_last_used_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_permission_last_used failed: unknown result")

    def get_account_creation_time(self, account):
        """
        Parameters:
         - account

        """
        self.send_get_account_creation_time(account)
        return self.recv_get_account_creation_time()

    def send_get_account_creation_time(self, account):
        self._oprot.writeMessageBegin('get_account_creation_time', TMessageType.CALL, self._seqid)
        args = get_account_creation_time_args()
        args.account = account
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_account_creation_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_account_creation_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_account_creation_time failed: unknown result")

    def prints(self, cstr):
        """
        Parameters:
         - cstr

        """
        self.send_prints(cstr)
        self.recv_prints()

    def send_prints(self, cstr):
        self._oprot.writeMessageBegin('prints', TMessageType.CALL, self._seqid)
        args = prints_args()
        args.cstr = cstr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def prints_l(self, cstr):
        """
        Parameters:
         - cstr

        """
        self.send_prints_l(cstr)
        self.recv_prints_l()

    def send_prints_l(self, cstr):
        self._oprot.writeMessageBegin('prints_l', TMessageType.CALL, self._seqid)
        args = prints_l_args()
        args.cstr = cstr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prints_l(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prints_l_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printi(self, n):
        """
        Parameters:
         - n

        """
        self.send_printi(n)
        self.recv_printi()

    def send_printi(self, n):
        self._oprot.writeMessageBegin('printi', TMessageType.CALL, self._seqid)
        args = printi_args()
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printui(self, n):
        """
        Parameters:
         - n

        """
        self.send_printui(n)
        self.recv_printui()

    def send_printui(self, n):
        self._oprot.writeMessageBegin('printui', TMessageType.CALL, self._seqid)
        args = printui_args()
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printui(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printui_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printi128(self, value):
        """
        Parameters:
         - value

        """
        self.send_printi128(value)
        self.recv_printi128()

    def send_printi128(self, value):
        self._oprot.writeMessageBegin('printi128', TMessageType.CALL, self._seqid)
        args = printi128_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printi128(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printi128_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printui128(self, value):
        """
        Parameters:
         - value

        """
        self.send_printui128(value)
        self.recv_printui128()

    def send_printui128(self, value):
        self._oprot.writeMessageBegin('printui128', TMessageType.CALL, self._seqid)
        args = printui128_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printui128(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printui128_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printsf(self, value):
        """
        Parameters:
         - value

        """
        self.send_printsf(value)
        self.recv_printsf()

    def send_printsf(self, value):
        self._oprot.writeMessageBegin('printsf', TMessageType.CALL, self._seqid)
        args = printsf_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printsf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printsf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printdf(self, value):
        """
        Parameters:
         - value

        """
        self.send_printdf(value)
        self.recv_printdf()

    def send_printdf(self, value):
        self._oprot.writeMessageBegin('printdf', TMessageType.CALL, self._seqid)
        args = printdf_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printdf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printdf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printqf(self, value):
        """
        Parameters:
         - value

        """
        self.send_printqf(value)
        self.recv_printqf()

    def send_printqf(self, value):
        self._oprot.writeMessageBegin('printqf', TMessageType.CALL, self._seqid)
        args = printqf_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printqf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printqf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printn(self, name):
        """
        Parameters:
         - name

        """
        self.send_printn(name)
        self.recv_printn()

    def send_printn(self, name):
        self._oprot.writeMessageBegin('printn', TMessageType.CALL, self._seqid)
        args = printn_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def printhex(self, data):
        """
        Parameters:
         - data

        """
        self.send_printhex(data)
        self.recv_printhex()

    def send_printhex(self, data):
        self._oprot.writeMessageBegin('printhex', TMessageType.CALL, self._seqid)
        args = printhex_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_printhex(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = printhex_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def action_data_size(self):
        self.send_action_data_size()
        return self.recv_action_data_size()

    def send_action_data_size(self):
        self._oprot.writeMessageBegin('action_data_size', TMessageType.CALL, self._seqid)
        args = action_data_size_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_action_data_size(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = action_data_size_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "action_data_size failed: unknown result")

    def read_action_data(self):
        self.send_read_action_data()
        return self.recv_read_action_data()

    def send_read_action_data(self):
        self._oprot.writeMessageBegin('read_action_data', TMessageType.CALL, self._seqid)
        args = read_action_data_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_action_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_action_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_action_data failed: unknown result")

    def require_recipient(self, name):
        """
        Parameters:
         - name

        """
        self.send_require_recipient(name)
        self.recv_require_recipient()

    def send_require_recipient(self, name):
        self._oprot.writeMessageBegin('require_recipient', TMessageType.CALL, self._seqid)
        args = require_recipient_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_require_recipient(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = require_recipient_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def require_auth(self, name):
        """
        Parameters:
         - name

        """
        self.send_require_auth(name)
        self.recv_require_auth()

    def send_require_auth(self, name):
        self._oprot.writeMessageBegin('require_auth', TMessageType.CALL, self._seqid)
        args = require_auth_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_require_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = require_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def has_auth(self, name):
        """
        Parameters:
         - name

        """
        self.send_has_auth(name)
        return self.recv_has_auth()

    def send_has_auth(self, name):
        self._oprot.writeMessageBegin('has_auth', TMessageType.CALL, self._seqid)
        args = has_auth_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "has_auth failed: unknown result")

    def require_auth2(self, name, permission):
        """
        Parameters:
         - name
         - permission

        """
        self.send_require_auth2(name, permission)
        self.recv_require_auth2()

    def send_require_auth2(self, name, permission):
        self._oprot.writeMessageBegin('require_auth2', TMessageType.CALL, self._seqid)
        args = require_auth2_args()
        args.name = name
        args.permission = permission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_require_auth2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = require_auth2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def is_account(self, name):
        """
        Parameters:
         - name

        """
        self.send_is_account(name)
        return self.recv_is_account()

    def send_is_account(self, name):
        self._oprot.writeMessageBegin('is_account', TMessageType.CALL, self._seqid)
        args = is_account_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_account(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_account_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_account failed: unknown result")

    def send_inline(self, serialized_action):
        """
        Parameters:
         - serialized_action

        """
        self.send_send_inline(serialized_action)
        self.recv_send_inline()

    def send_send_inline(self, serialized_action):
        self._oprot.writeMessageBegin('send_inline', TMessageType.CALL, self._seqid)
        args = send_inline_args()
        args.serialized_action = serialized_action
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_send_inline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = send_inline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def send_context_free_inline(self, serialized_data):
        """
        Parameters:
         - serialized_data

        """
        self.send_send_context_free_inline(serialized_data)
        self.recv_send_context_free_inline()

    def send_send_context_free_inline(self, serialized_data):
        self._oprot.writeMessageBegin('send_context_free_inline', TMessageType.CALL, self._seqid)
        args = send_context_free_inline_args()
        args.serialized_data = serialized_data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_send_context_free_inline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = send_context_free_inline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def publication_time(self):
        self.send_publication_time()
        return self.recv_publication_time()

    def send_publication_time(self):
        self._oprot.writeMessageBegin('publication_time', TMessageType.CALL, self._seqid)
        args = publication_time_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_publication_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = publication_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "publication_time failed: unknown result")

    def current_receiver(self):
        self.send_current_receiver()
        return self.recv_current_receiver()

    def send_current_receiver(self):
        self._oprot.writeMessageBegin('current_receiver', TMessageType.CALL, self._seqid)
        args = current_receiver_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_current_receiver(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = current_receiver_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "current_receiver failed: unknown result")

    def eosio_assert(self, test, msg):
        """
        Parameters:
         - test
         - msg

        """
        self.send_eosio_assert(test, msg)
        self.recv_eosio_assert()

    def send_eosio_assert(self, test, msg):
        self._oprot.writeMessageBegin('eosio_assert', TMessageType.CALL, self._seqid)
        args = eosio_assert_args()
        args.test = test
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_eosio_assert(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = eosio_assert_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def eosio_assert_message(self, test, msg):
        """
        Parameters:
         - test
         - msg

        """
        self.send_eosio_assert_message(test, msg)
        self.recv_eosio_assert_message()

    def send_eosio_assert_message(self, test, msg):
        self._oprot.writeMessageBegin('eosio_assert_message', TMessageType.CALL, self._seqid)
        args = eosio_assert_message_args()
        args.test = test
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_eosio_assert_message(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = eosio_assert_message_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def eosio_assert_code(self, test, code):
        """
        Parameters:
         - test
         - code

        """
        self.send_eosio_assert_code(test, code)
        self.recv_eosio_assert_code()

    def send_eosio_assert_code(self, test, code):
        self._oprot.writeMessageBegin('eosio_assert_code', TMessageType.CALL, self._seqid)
        args = eosio_assert_code_args()
        args.test = test
        args.code = code
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_eosio_assert_code(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = eosio_assert_code_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def eosio_exit(self, code):
        """
        Parameters:
         - code

        """
        self.send_eosio_exit(code)
        self.recv_eosio_exit()

    def send_eosio_exit(self, code):
        self._oprot.writeMessageBegin('eosio_exit', TMessageType.CALL, self._seqid)
        args = eosio_exit_args()
        args.code = code
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_eosio_exit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = eosio_exit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def current_time(self):
        self.send_current_time()
        return self.recv_current_time()

    def send_current_time(self):
        self._oprot.writeMessageBegin('current_time', TMessageType.CALL, self._seqid)
        args = current_time_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_current_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = current_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "current_time failed: unknown result")

    def is_feature_activated(self, feature_digest):
        """
        Parameters:
         - feature_digest

        """
        self.send_is_feature_activated(feature_digest)
        return self.recv_is_feature_activated()

    def send_is_feature_activated(self, feature_digest):
        self._oprot.writeMessageBegin('is_feature_activated', TMessageType.CALL, self._seqid)
        args = is_feature_activated_args()
        args.feature_digest = feature_digest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_feature_activated(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_feature_activated_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_feature_activated failed: unknown result")

    def get_sender(self):
        self.send_get_sender()
        return self.recv_get_sender()

    def send_get_sender(self):
        self._oprot.writeMessageBegin('get_sender', TMessageType.CALL, self._seqid)
        args = get_sender_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sender(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sender_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sender failed: unknown result")

    def assert_sha256(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        self.send_assert_sha256(data, hash)
        self.recv_assert_sha256()

    def send_assert_sha256(self, data, hash):
        self._oprot.writeMessageBegin('assert_sha256', TMessageType.CALL, self._seqid)
        args = assert_sha256_args()
        args.data = data
        args.hash = hash
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assert_sha256(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assert_sha256_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def assert_sha1(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        self.send_assert_sha1(data, hash)
        self.recv_assert_sha1()

    def send_assert_sha1(self, data, hash):
        self._oprot.writeMessageBegin('assert_sha1', TMessageType.CALL, self._seqid)
        args = assert_sha1_args()
        args.data = data
        args.hash = hash
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assert_sha1(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assert_sha1_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def assert_sha512(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        self.send_assert_sha512(data, hash)
        self.recv_assert_sha512()

    def send_assert_sha512(self, data, hash):
        self._oprot.writeMessageBegin('assert_sha512', TMessageType.CALL, self._seqid)
        args = assert_sha512_args()
        args.data = data
        args.hash = hash
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assert_sha512(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assert_sha512_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def assert_ripemd160(self, data, hash):
        """
        Parameters:
         - data
         - hash

        """
        self.send_assert_ripemd160(data, hash)
        self.recv_assert_ripemd160()

    def send_assert_ripemd160(self, data, hash):
        self._oprot.writeMessageBegin('assert_ripemd160', TMessageType.CALL, self._seqid)
        args = assert_ripemd160_args()
        args.data = data
        args.hash = hash
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assert_ripemd160(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assert_ripemd160_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def sha256(self, data):
        """
        Parameters:
         - data

        """
        self.send_sha256(data)
        return self.recv_sha256()

    def send_sha256(self, data):
        self._oprot.writeMessageBegin('sha256', TMessageType.CALL, self._seqid)
        args = sha256_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sha256(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sha256_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sha256 failed: unknown result")

    def sha1(self, data):
        """
        Parameters:
         - data

        """
        self.send_sha1(data)
        return self.recv_sha1()

    def send_sha1(self, data):
        self._oprot.writeMessageBegin('sha1', TMessageType.CALL, self._seqid)
        args = sha1_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sha1(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sha1_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sha1 failed: unknown result")

    def sha512(self, data):
        """
        Parameters:
         - data

        """
        self.send_sha512(data)
        return self.recv_sha512()

    def send_sha512(self, data):
        self._oprot.writeMessageBegin('sha512', TMessageType.CALL, self._seqid)
        args = sha512_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sha512(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sha512_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sha512 failed: unknown result")

    def ripemd160(self, data):
        """
        Parameters:
         - data

        """
        self.send_ripemd160(data)
        return self.recv_ripemd160()

    def send_ripemd160(self, data):
        self._oprot.writeMessageBegin('ripemd160', TMessageType.CALL, self._seqid)
        args = ripemd160_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ripemd160(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ripemd160_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ripemd160 failed: unknown result")

    def recover_key(self, digest, sig):
        """
        Parameters:
         - digest
         - sig

        """
        self.send_recover_key(digest, sig)
        return self.recv_recover_key()

    def send_recover_key(self, digest, sig):
        self._oprot.writeMessageBegin('recover_key', TMessageType.CALL, self._seqid)
        args = recover_key_args()
        args.digest = digest
        args.sig = sig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_recover_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = recover_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "recover_key failed: unknown result")

    def assert_recover_key(self, digest, sig, pub):
        """
        Parameters:
         - digest
         - sig
         - pub

        """
        self.send_assert_recover_key(digest, sig, pub)
        self.recv_assert_recover_key()

    def send_assert_recover_key(self, digest, sig, pub):
        self._oprot.writeMessageBegin('assert_recover_key', TMessageType.CALL, self._seqid)
        args = assert_recover_key_args()
        args.digest = digest
        args.sig = sig
        args.pub = pub
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assert_recover_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assert_recover_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def send_deferred(self, sender_id, payer, serialized_transaction, replace_existing):
        """
        Parameters:
         - sender_id
         - payer
         - serialized_transaction
         - replace_existing

        """
        self.send_send_deferred(sender_id, payer, serialized_transaction, replace_existing)
        self.recv_send_deferred()

    def send_send_deferred(self, sender_id, payer, serialized_transaction, replace_existing):
        self._oprot.writeMessageBegin('send_deferred', TMessageType.CALL, self._seqid)
        args = send_deferred_args()
        args.sender_id = sender_id
        args.payer = payer
        args.serialized_transaction = serialized_transaction
        args.replace_existing = replace_existing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_send_deferred(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = send_deferred_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def cancel_deferred(self, sender_id):
        """
        Parameters:
         - sender_id

        """
        self.send_cancel_deferred(sender_id)
        return self.recv_cancel_deferred()

    def send_cancel_deferred(self, sender_id):
        self._oprot.writeMessageBegin('cancel_deferred', TMessageType.CALL, self._seqid)
        args = cancel_deferred_args()
        args.sender_id = sender_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_deferred(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_deferred_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cancel_deferred failed: unknown result")

    def read_transaction(self):
        self.send_read_transaction()
        return self.recv_read_transaction()

    def send_read_transaction(self):
        self._oprot.writeMessageBegin('read_transaction', TMessageType.CALL, self._seqid)
        args = read_transaction_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_transaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_transaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_transaction failed: unknown result")

    def transaction_size(self):
        self.send_transaction_size()
        return self.recv_transaction_size()

    def send_transaction_size(self):
        self._oprot.writeMessageBegin('transaction_size', TMessageType.CALL, self._seqid)
        args = transaction_size_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transaction_size(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transaction_size_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transaction_size failed: unknown result")

    def tapos_block_num(self):
        self.send_tapos_block_num()
        return self.recv_tapos_block_num()

    def send_tapos_block_num(self):
        self._oprot.writeMessageBegin('tapos_block_num', TMessageType.CALL, self._seqid)
        args = tapos_block_num_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tapos_block_num(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tapos_block_num_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tapos_block_num failed: unknown result")

    def tapos_block_prefix(self):
        self.send_tapos_block_prefix()
        return self.recv_tapos_block_prefix()

    def send_tapos_block_prefix(self):
        self._oprot.writeMessageBegin('tapos_block_prefix', TMessageType.CALL, self._seqid)
        args = tapos_block_prefix_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tapos_block_prefix(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tapos_block_prefix_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tapos_block_prefix failed: unknown result")

    def expiration(self):
        self.send_expiration()
        return self.recv_expiration()

    def send_expiration(self):
        self._oprot.writeMessageBegin('expiration', TMessageType.CALL, self._seqid)
        args = expiration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expiration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expiration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expiration failed: unknown result")

    def get_action(self, _type, index):
        """
        Parameters:
         - _type
         - index

        """
        self.send_get_action(_type, index)
        return self.recv_get_action()

    def send_get_action(self, _type, index):
        self._oprot.writeMessageBegin('get_action', TMessageType.CALL, self._seqid)
        args = get_action_args()
        args._type = _type
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_action failed: unknown result")

    def get_context_free_data(self, index):
        """
        Parameters:
         - index

        """
        self.send_get_context_free_data(index)
        return self.recv_get_context_free_data()

    def send_get_context_free_data(self, index):
        self._oprot.writeMessageBegin('get_context_free_data', TMessageType.CALL, self._seqid)
        args = get_context_free_data_args()
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_context_free_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_context_free_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_context_free_data failed: unknown result")

    def db_store_i64(self, scope, table, payer, id, data):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - data

        """
        self.send_db_store_i64(scope, table, payer, id, data)
        return self.recv_db_store_i64()

    def send_db_store_i64(self, scope, table, payer, id, data):
        self._oprot.writeMessageBegin('db_store_i64', TMessageType.CALL, self._seqid)
        args = db_store_i64_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_store_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_store_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_store_i64 failed: unknown result")

    def db_update_i64(self, iterator, payer, data):
        """
        Parameters:
         - iterator
         - payer
         - data

        """
        self.send_db_update_i64(iterator, payer, data)
        self.recv_db_update_i64()

    def send_db_update_i64(self, iterator, payer, data):
        self._oprot.writeMessageBegin('db_update_i64', TMessageType.CALL, self._seqid)
        args = db_update_i64_args()
        args.iterator = iterator
        args.payer = payer
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_update_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_update_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_remove_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_remove_i64(iterator)
        self.recv_db_remove_i64()

    def send_db_remove_i64(self, iterator):
        self._oprot.writeMessageBegin('db_remove_i64', TMessageType.CALL, self._seqid)
        args = db_remove_i64_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_remove_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_remove_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_get_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_get_i64(iterator)
        return self.recv_db_get_i64()

    def send_db_get_i64(self, iterator):
        self._oprot.writeMessageBegin('db_get_i64', TMessageType.CALL, self._seqid)
        args = db_get_i64_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_get_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_get_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_get_i64 failed: unknown result")

    def db_next_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_next_i64(iterator)
        return self.recv_db_next_i64()

    def send_db_next_i64(self, iterator):
        self._oprot.writeMessageBegin('db_next_i64', TMessageType.CALL, self._seqid)
        args = db_next_i64_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_next_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_next_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_next_i64 failed: unknown result")

    def db_previous_i64(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_previous_i64(iterator)
        return self.recv_db_previous_i64()

    def send_db_previous_i64(self, iterator):
        self._oprot.writeMessageBegin('db_previous_i64', TMessageType.CALL, self._seqid)
        args = db_previous_i64_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_previous_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_previous_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_previous_i64 failed: unknown result")

    def db_find_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        self.send_db_find_i64(code, scope, table, id)
        return self.recv_db_find_i64()

    def send_db_find_i64(self, code, scope, table, id):
        self._oprot.writeMessageBegin('db_find_i64', TMessageType.CALL, self._seqid)
        args = db_find_i64_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_find_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_find_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_find_i64 failed: unknown result")

    def db_lowerbound_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        self.send_db_lowerbound_i64(code, scope, table, id)
        return self.recv_db_lowerbound_i64()

    def send_db_lowerbound_i64(self, code, scope, table, id):
        self._oprot.writeMessageBegin('db_lowerbound_i64', TMessageType.CALL, self._seqid)
        args = db_lowerbound_i64_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_lowerbound_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_lowerbound_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_lowerbound_i64 failed: unknown result")

    def db_upperbound_i64(self, code, scope, table, id):
        """
        Parameters:
         - code
         - scope
         - table
         - id

        """
        self.send_db_upperbound_i64(code, scope, table, id)
        return self.recv_db_upperbound_i64()

    def send_db_upperbound_i64(self, code, scope, table, id):
        self._oprot.writeMessageBegin('db_upperbound_i64', TMessageType.CALL, self._seqid)
        args = db_upperbound_i64_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_upperbound_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_upperbound_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_upperbound_i64 failed: unknown result")

    def db_end_i64(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_end_i64(code, scope, table)
        return self.recv_db_end_i64()

    def send_db_end_i64(self, code, scope, table):
        self._oprot.writeMessageBegin('db_end_i64', TMessageType.CALL, self._seqid)
        args = db_end_i64_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_end_i64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_end_i64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_end_i64 failed: unknown result")

    def db_idx64_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        self.send_db_idx64_store(scope, table, payer, id, secondary)
        return self.recv_db_idx64_store()

    def send_db_idx64_store(self, scope, table, payer, id, secondary):
        self._oprot.writeMessageBegin('db_idx64_store', TMessageType.CALL, self._seqid)
        args = db_idx64_store_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_store(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_store_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_store failed: unknown result")

    def db_idx64_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        self.send_db_idx64_update(iterator, payer, secondary)
        self.recv_db_idx64_update()

    def send_db_idx64_update(self, iterator, payer, secondary):
        self._oprot.writeMessageBegin('db_idx64_update', TMessageType.CALL, self._seqid)
        args = db_idx64_update_args()
        args.iterator = iterator
        args.payer = payer
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx64_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx64_remove(iterator)
        self.recv_db_idx64_remove()

    def send_db_idx64_remove(self, iterator):
        self._oprot.writeMessageBegin('db_idx64_remove', TMessageType.CALL, self._seqid)
        args = db_idx64_remove_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_remove(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_remove_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx64_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx64_next(iterator)
        return self.recv_db_idx64_next()

    def send_db_idx64_next(self, iterator):
        self._oprot.writeMessageBegin('db_idx64_next', TMessageType.CALL, self._seqid)
        args = db_idx64_next_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_next failed: unknown result")

    def db_idx64_previous(self, iteratory):
        """
        Parameters:
         - iteratory

        """
        self.send_db_idx64_previous(iteratory)
        return self.recv_db_idx64_previous()

    def send_db_idx64_previous(self, iteratory):
        self._oprot.writeMessageBegin('db_idx64_previous', TMessageType.CALL, self._seqid)
        args = db_idx64_previous_args()
        args.iteratory = iteratory
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_previous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_previous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_previous failed: unknown result")

    def db_idx64_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        self.send_db_idx64_find_primary(code, scope, table, primary)
        return self.recv_db_idx64_find_primary()

    def send_db_idx64_find_primary(self, code, scope, table, primary):
        self._oprot.writeMessageBegin('db_idx64_find_primary', TMessageType.CALL, self._seqid)
        args = db_idx64_find_primary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_find_primary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_find_primary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_find_primary failed: unknown result")

    def db_idx64_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        self.send_db_idx64_find_secondary(code, scope, table, secondary)
        return self.recv_db_idx64_find_secondary()

    def send_db_idx64_find_secondary(self, code, scope, table, secondary):
        self._oprot.writeMessageBegin('db_idx64_find_secondary', TMessageType.CALL, self._seqid)
        args = db_idx64_find_secondary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_find_secondary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_find_secondary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_find_secondary failed: unknown result")

    def db_idx64_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx64_lowerbound(code, scope, table, secondary, primary)
        return self.recv_db_idx64_lowerbound()

    def send_db_idx64_lowerbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx64_lowerbound', TMessageType.CALL, self._seqid)
        args = db_idx64_lowerbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_lowerbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_lowerbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_lowerbound failed: unknown result")

    def db_idx64_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx64_upperbound(code, scope, table, secondary, primary)
        return self.recv_db_idx64_upperbound()

    def send_db_idx64_upperbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx64_upperbound', TMessageType.CALL, self._seqid)
        args = db_idx64_upperbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_upperbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_upperbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_upperbound failed: unknown result")

    def db_idx64_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_idx64_end(code, scope, table)
        return self.recv_db_idx64_end()

    def send_db_idx64_end(self, code, scope, table):
        self._oprot.writeMessageBegin('db_idx64_end', TMessageType.CALL, self._seqid)
        args = db_idx64_end_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx64_end(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx64_end_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx64_end failed: unknown result")

    def db_idx128_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        self.send_db_idx128_store(scope, table, payer, id, secondary)
        return self.recv_db_idx128_store()

    def send_db_idx128_store(self, scope, table, payer, id, secondary):
        self._oprot.writeMessageBegin('db_idx128_store', TMessageType.CALL, self._seqid)
        args = db_idx128_store_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_store(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_store_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_store failed: unknown result")

    def db_idx128_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        self.send_db_idx128_update(iterator, payer, secondary)
        self.recv_db_idx128_update()

    def send_db_idx128_update(self, iterator, payer, secondary):
        self._oprot.writeMessageBegin('db_idx128_update', TMessageType.CALL, self._seqid)
        args = db_idx128_update_args()
        args.iterator = iterator
        args.payer = payer
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx128_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx128_remove(iterator)
        self.recv_db_idx128_remove()

    def send_db_idx128_remove(self, iterator):
        self._oprot.writeMessageBegin('db_idx128_remove', TMessageType.CALL, self._seqid)
        args = db_idx128_remove_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_remove(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_remove_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx128_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx128_next(iterator)
        return self.recv_db_idx128_next()

    def send_db_idx128_next(self, iterator):
        self._oprot.writeMessageBegin('db_idx128_next', TMessageType.CALL, self._seqid)
        args = db_idx128_next_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_next failed: unknown result")

    def db_idx128_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx128_previous(iterator)
        return self.recv_db_idx128_previous()

    def send_db_idx128_previous(self, iterator):
        self._oprot.writeMessageBegin('db_idx128_previous', TMessageType.CALL, self._seqid)
        args = db_idx128_previous_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_previous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_previous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_previous failed: unknown result")

    def db_idx128_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        self.send_db_idx128_find_primary(code, scope, table, primary)
        return self.recv_db_idx128_find_primary()

    def send_db_idx128_find_primary(self, code, scope, table, primary):
        self._oprot.writeMessageBegin('db_idx128_find_primary', TMessageType.CALL, self._seqid)
        args = db_idx128_find_primary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_find_primary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_find_primary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_find_primary failed: unknown result")

    def db_idx128_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        self.send_db_idx128_find_secondary(code, scope, table, secondary)
        return self.recv_db_idx128_find_secondary()

    def send_db_idx128_find_secondary(self, code, scope, table, secondary):
        self._oprot.writeMessageBegin('db_idx128_find_secondary', TMessageType.CALL, self._seqid)
        args = db_idx128_find_secondary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_find_secondary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_find_secondary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_find_secondary failed: unknown result")

    def db_idx128_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx128_lowerbound(code, scope, table, secondary, primary)
        return self.recv_db_idx128_lowerbound()

    def send_db_idx128_lowerbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx128_lowerbound', TMessageType.CALL, self._seqid)
        args = db_idx128_lowerbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_lowerbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_lowerbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_lowerbound failed: unknown result")

    def db_idx128_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx128_upperbound(code, scope, table, secondary, primary)
        return self.recv_db_idx128_upperbound()

    def send_db_idx128_upperbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx128_upperbound', TMessageType.CALL, self._seqid)
        args = db_idx128_upperbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_upperbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_upperbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_upperbound failed: unknown result")

    def db_idx128_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_idx128_end(code, scope, table)
        return self.recv_db_idx128_end()

    def send_db_idx128_end(self, code, scope, table):
        self._oprot.writeMessageBegin('db_idx128_end', TMessageType.CALL, self._seqid)
        args = db_idx128_end_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx128_end(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx128_end_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx128_end failed: unknown result")

    def db_idx256_store(self, scope, table, payer, id, data):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - data

        """
        self.send_db_idx256_store(scope, table, payer, id, data)
        return self.recv_db_idx256_store()

    def send_db_idx256_store(self, scope, table, payer, id, data):
        self._oprot.writeMessageBegin('db_idx256_store', TMessageType.CALL, self._seqid)
        args = db_idx256_store_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_store(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_store_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_store failed: unknown result")

    def db_idx256_update(self, iterator, payer, data):
        """
        Parameters:
         - iterator
         - payer
         - data

        """
        self.send_db_idx256_update(iterator, payer, data)
        self.recv_db_idx256_update()

    def send_db_idx256_update(self, iterator, payer, data):
        self._oprot.writeMessageBegin('db_idx256_update', TMessageType.CALL, self._seqid)
        args = db_idx256_update_args()
        args.iterator = iterator
        args.payer = payer
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx256_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx256_remove(iterator)
        self.recv_db_idx256_remove()

    def send_db_idx256_remove(self, iterator):
        self._oprot.writeMessageBegin('db_idx256_remove', TMessageType.CALL, self._seqid)
        args = db_idx256_remove_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_remove(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_remove_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx256_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx256_next(iterator)
        return self.recv_db_idx256_next()

    def send_db_idx256_next(self, iterator):
        self._oprot.writeMessageBegin('db_idx256_next', TMessageType.CALL, self._seqid)
        args = db_idx256_next_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_next failed: unknown result")

    def db_idx256_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx256_previous(iterator)
        return self.recv_db_idx256_previous()

    def send_db_idx256_previous(self, iterator):
        self._oprot.writeMessageBegin('db_idx256_previous', TMessageType.CALL, self._seqid)
        args = db_idx256_previous_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_previous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_previous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_previous failed: unknown result")

    def db_idx256_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        self.send_db_idx256_find_primary(code, scope, table, primary)
        return self.recv_db_idx256_find_primary()

    def send_db_idx256_find_primary(self, code, scope, table, primary):
        self._oprot.writeMessageBegin('db_idx256_find_primary', TMessageType.CALL, self._seqid)
        args = db_idx256_find_primary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_find_primary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_find_primary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_find_primary failed: unknown result")

    def db_idx256_find_secondary(self, code, scope, table, data):
        """
        Parameters:
         - code
         - scope
         - table
         - data

        """
        self.send_db_idx256_find_secondary(code, scope, table, data)
        return self.recv_db_idx256_find_secondary()

    def send_db_idx256_find_secondary(self, code, scope, table, data):
        self._oprot.writeMessageBegin('db_idx256_find_secondary', TMessageType.CALL, self._seqid)
        args = db_idx256_find_secondary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_find_secondary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_find_secondary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_find_secondary failed: unknown result")

    def db_idx256_lowerbound(self, code, scope, table, data, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - data
         - primary

        """
        self.send_db_idx256_lowerbound(code, scope, table, data, primary)
        return self.recv_db_idx256_lowerbound()

    def send_db_idx256_lowerbound(self, code, scope, table, data, primary):
        self._oprot.writeMessageBegin('db_idx256_lowerbound', TMessageType.CALL, self._seqid)
        args = db_idx256_lowerbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.data = data
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_lowerbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_lowerbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_lowerbound failed: unknown result")

    def db_idx256_upperbound(self, code, scope, table, data, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - data
         - primary

        """
        self.send_db_idx256_upperbound(code, scope, table, data, primary)
        return self.recv_db_idx256_upperbound()

    def send_db_idx256_upperbound(self, code, scope, table, data, primary):
        self._oprot.writeMessageBegin('db_idx256_upperbound', TMessageType.CALL, self._seqid)
        args = db_idx256_upperbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.data = data
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_upperbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_upperbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_upperbound failed: unknown result")

    def db_idx256_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_idx256_end(code, scope, table)
        return self.recv_db_idx256_end()

    def send_db_idx256_end(self, code, scope, table):
        self._oprot.writeMessageBegin('db_idx256_end', TMessageType.CALL, self._seqid)
        args = db_idx256_end_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx256_end(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx256_end_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx256_end failed: unknown result")

    def db_idx_double_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        self.send_db_idx_double_store(scope, table, payer, id, secondary)
        return self.recv_db_idx_double_store()

    def send_db_idx_double_store(self, scope, table, payer, id, secondary):
        self._oprot.writeMessageBegin('db_idx_double_store', TMessageType.CALL, self._seqid)
        args = db_idx_double_store_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_store(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_store_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_store failed: unknown result")

    def db_idx_double_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        self.send_db_idx_double_update(iterator, payer, secondary)
        self.recv_db_idx_double_update()

    def send_db_idx_double_update(self, iterator, payer, secondary):
        self._oprot.writeMessageBegin('db_idx_double_update', TMessageType.CALL, self._seqid)
        args = db_idx_double_update_args()
        args.iterator = iterator
        args.payer = payer
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx_double_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_double_remove(iterator)
        self.recv_db_idx_double_remove()

    def send_db_idx_double_remove(self, iterator):
        self._oprot.writeMessageBegin('db_idx_double_remove', TMessageType.CALL, self._seqid)
        args = db_idx_double_remove_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_remove(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_remove_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx_double_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_double_next(iterator)
        return self.recv_db_idx_double_next()

    def send_db_idx_double_next(self, iterator):
        self._oprot.writeMessageBegin('db_idx_double_next', TMessageType.CALL, self._seqid)
        args = db_idx_double_next_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_next failed: unknown result")

    def db_idx_double_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_double_previous(iterator)
        return self.recv_db_idx_double_previous()

    def send_db_idx_double_previous(self, iterator):
        self._oprot.writeMessageBegin('db_idx_double_previous', TMessageType.CALL, self._seqid)
        args = db_idx_double_previous_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_previous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_previous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_previous failed: unknown result")

    def db_idx_double_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        self.send_db_idx_double_find_primary(code, scope, table, primary)
        return self.recv_db_idx_double_find_primary()

    def send_db_idx_double_find_primary(self, code, scope, table, primary):
        self._oprot.writeMessageBegin('db_idx_double_find_primary', TMessageType.CALL, self._seqid)
        args = db_idx_double_find_primary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_find_primary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_find_primary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_find_primary failed: unknown result")

    def db_idx_double_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        self.send_db_idx_double_find_secondary(code, scope, table, secondary)
        return self.recv_db_idx_double_find_secondary()

    def send_db_idx_double_find_secondary(self, code, scope, table, secondary):
        self._oprot.writeMessageBegin('db_idx_double_find_secondary', TMessageType.CALL, self._seqid)
        args = db_idx_double_find_secondary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_find_secondary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_find_secondary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_find_secondary failed: unknown result")

    def db_idx_double_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx_double_lowerbound(code, scope, table, secondary, primary)
        return self.recv_db_idx_double_lowerbound()

    def send_db_idx_double_lowerbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx_double_lowerbound', TMessageType.CALL, self._seqid)
        args = db_idx_double_lowerbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_lowerbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_lowerbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_lowerbound failed: unknown result")

    def db_idx_double_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx_double_upperbound(code, scope, table, secondary, primary)
        return self.recv_db_idx_double_upperbound()

    def send_db_idx_double_upperbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx_double_upperbound', TMessageType.CALL, self._seqid)
        args = db_idx_double_upperbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_upperbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_upperbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_upperbound failed: unknown result")

    def db_idx_double_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_idx_double_end(code, scope, table)
        return self.recv_db_idx_double_end()

    def send_db_idx_double_end(self, code, scope, table):
        self._oprot.writeMessageBegin('db_idx_double_end', TMessageType.CALL, self._seqid)
        args = db_idx_double_end_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_double_end(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_double_end_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_double_end failed: unknown result")

    def db_idx_long_double_store(self, scope, table, payer, id, secondary):
        """
        Parameters:
         - scope
         - table
         - payer
         - id
         - secondary

        """
        self.send_db_idx_long_double_store(scope, table, payer, id, secondary)
        return self.recv_db_idx_long_double_store()

    def send_db_idx_long_double_store(self, scope, table, payer, id, secondary):
        self._oprot.writeMessageBegin('db_idx_long_double_store', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_store_args()
        args.scope = scope
        args.table = table
        args.payer = payer
        args.id = id
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_store(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_store_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_store failed: unknown result")

    def db_idx_long_double_update(self, iterator, payer, secondary):
        """
        Parameters:
         - iterator
         - payer
         - secondary

        """
        self.send_db_idx_long_double_update(iterator, payer, secondary)
        self.recv_db_idx_long_double_update()

    def send_db_idx_long_double_update(self, iterator, payer, secondary):
        self._oprot.writeMessageBegin('db_idx_long_double_update', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_update_args()
        args.iterator = iterator
        args.payer = payer
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx_long_double_remove(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_long_double_remove(iterator)
        self.recv_db_idx_long_double_remove()

    def send_db_idx_long_double_remove(self, iterator):
        self._oprot.writeMessageBegin('db_idx_long_double_remove', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_remove_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_remove(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_remove_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def db_idx_long_double_next(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_long_double_next(iterator)
        return self.recv_db_idx_long_double_next()

    def send_db_idx_long_double_next(self, iterator):
        self._oprot.writeMessageBegin('db_idx_long_double_next', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_next_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_next failed: unknown result")

    def db_idx_long_double_previous(self, iterator):
        """
        Parameters:
         - iterator

        """
        self.send_db_idx_long_double_previous(iterator)
        return self.recv_db_idx_long_double_previous()

    def send_db_idx_long_double_previous(self, iterator):
        self._oprot.writeMessageBegin('db_idx_long_double_previous', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_previous_args()
        args.iterator = iterator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_previous(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_previous_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_previous failed: unknown result")

    def db_idx_long_double_find_primary(self, code, scope, table, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - primary

        """
        self.send_db_idx_long_double_find_primary(code, scope, table, primary)
        return self.recv_db_idx_long_double_find_primary()

    def send_db_idx_long_double_find_primary(self, code, scope, table, primary):
        self._oprot.writeMessageBegin('db_idx_long_double_find_primary', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_find_primary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_find_primary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_find_primary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_find_primary failed: unknown result")

    def db_idx_long_double_find_secondary(self, code, scope, table, secondary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary

        """
        self.send_db_idx_long_double_find_secondary(code, scope, table, secondary)
        return self.recv_db_idx_long_double_find_secondary()

    def send_db_idx_long_double_find_secondary(self, code, scope, table, secondary):
        self._oprot.writeMessageBegin('db_idx_long_double_find_secondary', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_find_secondary_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_find_secondary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_find_secondary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_find_secondary failed: unknown result")

    def db_idx_long_double_lowerbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx_long_double_lowerbound(code, scope, table, secondary, primary)
        return self.recv_db_idx_long_double_lowerbound()

    def send_db_idx_long_double_lowerbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx_long_double_lowerbound', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_lowerbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_lowerbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_lowerbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_lowerbound failed: unknown result")

    def db_idx_long_double_upperbound(self, code, scope, table, secondary, primary):
        """
        Parameters:
         - code
         - scope
         - table
         - secondary
         - primary

        """
        self.send_db_idx_long_double_upperbound(code, scope, table, secondary, primary)
        return self.recv_db_idx_long_double_upperbound()

    def send_db_idx_long_double_upperbound(self, code, scope, table, secondary, primary):
        self._oprot.writeMessageBegin('db_idx_long_double_upperbound', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_upperbound_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.secondary = secondary
        args.primary = primary
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_upperbound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_upperbound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_upperbound failed: unknown result")

    def db_idx_long_double_end(self, code, scope, table):
        """
        Parameters:
         - code
         - scope
         - table

        """
        self.send_db_idx_long_double_end(code, scope, table)
        return self.recv_db_idx_long_double_end()

    def send_db_idx_long_double_end(self, code, scope, table):
        self._oprot.writeMessageBegin('db_idx_long_double_end', TMessageType.CALL, self._seqid)
        args = db_idx_long_double_end_args()
        args.code = code
        args.scope = scope
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_db_idx_long_double_end(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = db_idx_long_double_end_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "db_idx_long_double_end failed: unknown result")

    def set_action_return_value(self, data):
        """
        Parameters:
         - data

        """
        self.send_set_action_return_value(data)
        self.recv_set_action_return_value()

    def send_set_action_return_value(self, data):
        self._oprot.writeMessageBegin('set_action_return_value', TMessageType.CALL, self._seqid)
        args = set_action_return_value_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_action_return_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_action_return_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_code_hash(self, account, struct_version):
        """
        Parameters:
         - account
         - struct_version

        """
        self.send_get_code_hash(account, struct_version)
        return self.recv_get_code_hash()

    def send_get_code_hash(self, account, struct_version):
        self._oprot.writeMessageBegin('get_code_hash', TMessageType.CALL, self._seqid)
        args = get_code_hash_args()
        args.account = account
        args.struct_version = struct_version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_code_hash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_code_hash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_code_hash failed: unknown result")

    def get_block_num(self):
        self.send_get_block_num()
        return self.recv_get_block_num()

    def send_get_block_num(self):
        self._oprot.writeMessageBegin('get_block_num', TMessageType.CALL, self._seqid)
        args = get_block_num_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_block_num(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_block_num_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_block_num failed: unknown result")

    def sha3(self, data, keccak):
        """
        Parameters:
         - data
         - keccak

        """
        self.send_sha3(data, keccak)
        return self.recv_sha3()

    def send_sha3(self, data, keccak):
        self._oprot.writeMessageBegin('sha3', TMessageType.CALL, self._seqid)
        args = sha3_args()
        args.data = data
        args.keccak = keccak
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sha3(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sha3_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sha3 failed: unknown result")

    def blake2_f(self, rounds, state, msg, t0_offset, t1_offset, final):
        """
        Parameters:
         - rounds
         - state
         - msg
         - t0_offset
         - t1_offset
         - final

        """
        self.send_blake2_f(rounds, state, msg, t0_offset, t1_offset, final)
        return self.recv_blake2_f()

    def send_blake2_f(self, rounds, state, msg, t0_offset, t1_offset, final):
        self._oprot.writeMessageBegin('blake2_f', TMessageType.CALL, self._seqid)
        args = blake2_f_args()
        args.rounds = rounds
        args.state = state
        args.msg = msg
        args.t0_offset = t0_offset
        args.t1_offset = t1_offset
        args.final = final
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_blake2_f(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = blake2_f_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "blake2_f failed: unknown result")

    def k1_recover(self, sig, dig):
        """
        Parameters:
         - sig
         - dig

        """
        self.send_k1_recover(sig, dig)
        return self.recv_k1_recover()

    def send_k1_recover(self, sig, dig):
        self._oprot.writeMessageBegin('k1_recover', TMessageType.CALL, self._seqid)
        args = k1_recover_args()
        args.sig = sig
        args.dig = dig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_k1_recover(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = k1_recover_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "k1_recover failed: unknown result")

    def alt_bn128_add(self, op1, op2):
        """
        Parameters:
         - op1
         - op2

        """
        self.send_alt_bn128_add(op1, op2)
        return self.recv_alt_bn128_add()

    def send_alt_bn128_add(self, op1, op2):
        self._oprot.writeMessageBegin('alt_bn128_add', TMessageType.CALL, self._seqid)
        args = alt_bn128_add_args()
        args.op1 = op1
        args.op2 = op2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alt_bn128_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alt_bn128_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alt_bn128_add failed: unknown result")

    def alt_bn128_mul(self, g1, scalar):
        """
        Parameters:
         - g1
         - scalar

        """
        self.send_alt_bn128_mul(g1, scalar)
        return self.recv_alt_bn128_mul()

    def send_alt_bn128_mul(self, g1, scalar):
        self._oprot.writeMessageBegin('alt_bn128_mul', TMessageType.CALL, self._seqid)
        args = alt_bn128_mul_args()
        args.g1 = g1
        args.scalar = scalar
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alt_bn128_mul(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alt_bn128_mul_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alt_bn128_mul failed: unknown result")

    def alt_bn128_pair(self, pairs):
        """
        Parameters:
         - pairs

        """
        self.send_alt_bn128_pair(pairs)
        return self.recv_alt_bn128_pair()

    def send_alt_bn128_pair(self, pairs):
        self._oprot.writeMessageBegin('alt_bn128_pair', TMessageType.CALL, self._seqid)
        args = alt_bn128_pair_args()
        args.pairs = pairs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alt_bn128_pair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alt_bn128_pair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "alt_bn128_pair failed: unknown result")

    def mod_exp(self, base, exp, mod):
        """
        Parameters:
         - base
         - exp
         - mod

        """
        self.send_mod_exp(base, exp, mod)
        return self.recv_mod_exp()

    def send_mod_exp(self, base, exp, mod):
        self._oprot.writeMessageBegin('mod_exp', TMessageType.CALL, self._seqid)
        args = mod_exp_args()
        args.base = base
        args.exp = exp
        args.mod = mod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mod_exp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mod_exp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mod_exp failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["end_apply"] = Processor.process_end_apply
        self._processMap["get_active_producers"] = Processor.process_get_active_producers
        self._processMap["get_resource_limits"] = Processor.process_get_resource_limits
        self._processMap["set_resource_limits"] = Processor.process_set_resource_limits
        self._processMap["set_proposed_producers"] = Processor.process_set_proposed_producers
        self._processMap["set_proposed_producers_ex"] = Processor.process_set_proposed_producers_ex
        self._processMap["is_privileged"] = Processor.process_is_privileged
        self._processMap["set_privileged"] = Processor.process_set_privileged
        self._processMap["set_blockchain_parameters_packed"] = Processor.process_set_blockchain_parameters_packed
        self._processMap["get_blockchain_parameters_packed"] = Processor.process_get_blockchain_parameters_packed
        self._processMap["preactivate_feature"] = Processor.process_preactivate_feature
        self._processMap["check_transaction_authorization"] = Processor.process_check_transaction_authorization
        self._processMap["check_permission_authorization"] = Processor.process_check_permission_authorization
        self._processMap["get_permission_last_used"] = Processor.process_get_permission_last_used
        self._processMap["get_account_creation_time"] = Processor.process_get_account_creation_time
        self._processMap["prints"] = Processor.process_prints
        self._processMap["prints_l"] = Processor.process_prints_l
        self._processMap["printi"] = Processor.process_printi
        self._processMap["printui"] = Processor.process_printui
        self._processMap["printi128"] = Processor.process_printi128
        self._processMap["printui128"] = Processor.process_printui128
        self._processMap["printsf"] = Processor.process_printsf
        self._processMap["printdf"] = Processor.process_printdf
        self._processMap["printqf"] = Processor.process_printqf
        self._processMap["printn"] = Processor.process_printn
        self._processMap["printhex"] = Processor.process_printhex
        self._processMap["action_data_size"] = Processor.process_action_data_size
        self._processMap["read_action_data"] = Processor.process_read_action_data
        self._processMap["require_recipient"] = Processor.process_require_recipient
        self._processMap["require_auth"] = Processor.process_require_auth
        self._processMap["has_auth"] = Processor.process_has_auth
        self._processMap["require_auth2"] = Processor.process_require_auth2
        self._processMap["is_account"] = Processor.process_is_account
        self._processMap["send_inline"] = Processor.process_send_inline
        self._processMap["send_context_free_inline"] = Processor.process_send_context_free_inline
        self._processMap["publication_time"] = Processor.process_publication_time
        self._processMap["current_receiver"] = Processor.process_current_receiver
        self._processMap["eosio_assert"] = Processor.process_eosio_assert
        self._processMap["eosio_assert_message"] = Processor.process_eosio_assert_message
        self._processMap["eosio_assert_code"] = Processor.process_eosio_assert_code
        self._processMap["eosio_exit"] = Processor.process_eosio_exit
        self._processMap["current_time"] = Processor.process_current_time
        self._processMap["is_feature_activated"] = Processor.process_is_feature_activated
        self._processMap["get_sender"] = Processor.process_get_sender
        self._processMap["assert_sha256"] = Processor.process_assert_sha256
        self._processMap["assert_sha1"] = Processor.process_assert_sha1
        self._processMap["assert_sha512"] = Processor.process_assert_sha512
        self._processMap["assert_ripemd160"] = Processor.process_assert_ripemd160
        self._processMap["sha256"] = Processor.process_sha256
        self._processMap["sha1"] = Processor.process_sha1
        self._processMap["sha512"] = Processor.process_sha512
        self._processMap["ripemd160"] = Processor.process_ripemd160
        self._processMap["recover_key"] = Processor.process_recover_key
        self._processMap["assert_recover_key"] = Processor.process_assert_recover_key
        self._processMap["send_deferred"] = Processor.process_send_deferred
        self._processMap["cancel_deferred"] = Processor.process_cancel_deferred
        self._processMap["read_transaction"] = Processor.process_read_transaction
        self._processMap["transaction_size"] = Processor.process_transaction_size
        self._processMap["tapos_block_num"] = Processor.process_tapos_block_num
        self._processMap["tapos_block_prefix"] = Processor.process_tapos_block_prefix
        self._processMap["expiration"] = Processor.process_expiration
        self._processMap["get_action"] = Processor.process_get_action
        self._processMap["get_context_free_data"] = Processor.process_get_context_free_data
        self._processMap["db_store_i64"] = Processor.process_db_store_i64
        self._processMap["db_update_i64"] = Processor.process_db_update_i64
        self._processMap["db_remove_i64"] = Processor.process_db_remove_i64
        self._processMap["db_get_i64"] = Processor.process_db_get_i64
        self._processMap["db_next_i64"] = Processor.process_db_next_i64
        self._processMap["db_previous_i64"] = Processor.process_db_previous_i64
        self._processMap["db_find_i64"] = Processor.process_db_find_i64
        self._processMap["db_lowerbound_i64"] = Processor.process_db_lowerbound_i64
        self._processMap["db_upperbound_i64"] = Processor.process_db_upperbound_i64
        self._processMap["db_end_i64"] = Processor.process_db_end_i64
        self._processMap["db_idx64_store"] = Processor.process_db_idx64_store
        self._processMap["db_idx64_update"] = Processor.process_db_idx64_update
        self._processMap["db_idx64_remove"] = Processor.process_db_idx64_remove
        self._processMap["db_idx64_next"] = Processor.process_db_idx64_next
        self._processMap["db_idx64_previous"] = Processor.process_db_idx64_previous
        self._processMap["db_idx64_find_primary"] = Processor.process_db_idx64_find_primary
        self._processMap["db_idx64_find_secondary"] = Processor.process_db_idx64_find_secondary
        self._processMap["db_idx64_lowerbound"] = Processor.process_db_idx64_lowerbound
        self._processMap["db_idx64_upperbound"] = Processor.process_db_idx64_upperbound
        self._processMap["db_idx64_end"] = Processor.process_db_idx64_end
        self._processMap["db_idx128_store"] = Processor.process_db_idx128_store
        self._processMap["db_idx128_update"] = Processor.process_db_idx128_update
        self._processMap["db_idx128_remove"] = Processor.process_db_idx128_remove
        self._processMap["db_idx128_next"] = Processor.process_db_idx128_next
        self._processMap["db_idx128_previous"] = Processor.process_db_idx128_previous
        self._processMap["db_idx128_find_primary"] = Processor.process_db_idx128_find_primary
        self._processMap["db_idx128_find_secondary"] = Processor.process_db_idx128_find_secondary
        self._processMap["db_idx128_lowerbound"] = Processor.process_db_idx128_lowerbound
        self._processMap["db_idx128_upperbound"] = Processor.process_db_idx128_upperbound
        self._processMap["db_idx128_end"] = Processor.process_db_idx128_end
        self._processMap["db_idx256_store"] = Processor.process_db_idx256_store
        self._processMap["db_idx256_update"] = Processor.process_db_idx256_update
        self._processMap["db_idx256_remove"] = Processor.process_db_idx256_remove
        self._processMap["db_idx256_next"] = Processor.process_db_idx256_next
        self._processMap["db_idx256_previous"] = Processor.process_db_idx256_previous
        self._processMap["db_idx256_find_primary"] = Processor.process_db_idx256_find_primary
        self._processMap["db_idx256_find_secondary"] = Processor.process_db_idx256_find_secondary
        self._processMap["db_idx256_lowerbound"] = Processor.process_db_idx256_lowerbound
        self._processMap["db_idx256_upperbound"] = Processor.process_db_idx256_upperbound
        self._processMap["db_idx256_end"] = Processor.process_db_idx256_end
        self._processMap["db_idx_double_store"] = Processor.process_db_idx_double_store
        self._processMap["db_idx_double_update"] = Processor.process_db_idx_double_update
        self._processMap["db_idx_double_remove"] = Processor.process_db_idx_double_remove
        self._processMap["db_idx_double_next"] = Processor.process_db_idx_double_next
        self._processMap["db_idx_double_previous"] = Processor.process_db_idx_double_previous
        self._processMap["db_idx_double_find_primary"] = Processor.process_db_idx_double_find_primary
        self._processMap["db_idx_double_find_secondary"] = Processor.process_db_idx_double_find_secondary
        self._processMap["db_idx_double_lowerbound"] = Processor.process_db_idx_double_lowerbound
        self._processMap["db_idx_double_upperbound"] = Processor.process_db_idx_double_upperbound
        self._processMap["db_idx_double_end"] = Processor.process_db_idx_double_end
        self._processMap["db_idx_long_double_store"] = Processor.process_db_idx_long_double_store
        self._processMap["db_idx_long_double_update"] = Processor.process_db_idx_long_double_update
        self._processMap["db_idx_long_double_remove"] = Processor.process_db_idx_long_double_remove
        self._processMap["db_idx_long_double_next"] = Processor.process_db_idx_long_double_next
        self._processMap["db_idx_long_double_previous"] = Processor.process_db_idx_long_double_previous
        self._processMap["db_idx_long_double_find_primary"] = Processor.process_db_idx_long_double_find_primary
        self._processMap["db_idx_long_double_find_secondary"] = Processor.process_db_idx_long_double_find_secondary
        self._processMap["db_idx_long_double_lowerbound"] = Processor.process_db_idx_long_double_lowerbound
        self._processMap["db_idx_long_double_upperbound"] = Processor.process_db_idx_long_double_upperbound
        self._processMap["db_idx_long_double_end"] = Processor.process_db_idx_long_double_end
        self._processMap["set_action_return_value"] = Processor.process_set_action_return_value
        self._processMap["get_code_hash"] = Processor.process_get_code_hash
        self._processMap["get_block_num"] = Processor.process_get_block_num
        self._processMap["sha3"] = Processor.process_sha3
        self._processMap["blake2_f"] = Processor.process_blake2_f
        self._processMap["k1_recover"] = Processor.process_k1_recover
        self._processMap["alt_bn128_add"] = Processor.process_alt_bn128_add
        self._processMap["alt_bn128_mul"] = Processor.process_alt_bn128_mul
        self._processMap["alt_bn128_pair"] = Processor.process_alt_bn128_pair
        self._processMap["mod_exp"] = Processor.process_mod_exp
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_end_apply(self, seqid, iprot, oprot):
        args = end_apply_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_apply_result()
        try:
            result.success = self._handler.end_apply()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_apply", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_active_producers(self, seqid, iprot, oprot):
        args = get_active_producers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_active_producers_result()
        try:
            result.success = self._handler.get_active_producers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_active_producers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_resource_limits(self, seqid, iprot, oprot):
        args = get_resource_limits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_resource_limits_result()
        try:
            result.success = self._handler.get_resource_limits(args.account)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_resource_limits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_resource_limits(self, seqid, iprot, oprot):
        args = set_resource_limits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_resource_limits_result()
        try:
            self._handler.set_resource_limits(args.account, args.ram_bytes, args.net_weight, args.cpu_weight)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_resource_limits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_proposed_producers(self, seqid, iprot, oprot):
        args = set_proposed_producers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_proposed_producers_result()
        try:
            result.success = self._handler.set_proposed_producers(args.producer_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_proposed_producers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_proposed_producers_ex(self, seqid, iprot, oprot):
        args = set_proposed_producers_ex_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_proposed_producers_ex_result()
        try:
            result.success = self._handler.set_proposed_producers_ex(args.producer_data_format, args.producer_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_proposed_producers_ex", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_privileged(self, seqid, iprot, oprot):
        args = is_privileged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_privileged_result()
        try:
            result.success = self._handler.is_privileged(args.account)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_privileged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_privileged(self, seqid, iprot, oprot):
        args = set_privileged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_privileged_result()
        try:
            self._handler.set_privileged(args.account, args.is_priv)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_privileged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_blockchain_parameters_packed(self, seqid, iprot, oprot):
        args = set_blockchain_parameters_packed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_blockchain_parameters_packed_result()
        try:
            self._handler.set_blockchain_parameters_packed(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_blockchain_parameters_packed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_blockchain_parameters_packed(self, seqid, iprot, oprot):
        args = get_blockchain_parameters_packed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_blockchain_parameters_packed_result()
        try:
            result.success = self._handler.get_blockchain_parameters_packed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_blockchain_parameters_packed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_preactivate_feature(self, seqid, iprot, oprot):
        args = preactivate_feature_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = preactivate_feature_result()
        try:
            self._handler.preactivate_feature(args.feature_digest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("preactivate_feature", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_transaction_authorization(self, seqid, iprot, oprot):
        args = check_transaction_authorization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_transaction_authorization_result()
        try:
            result.success = self._handler.check_transaction_authorization(args.trx_data, args.pubkeys_data, args.perms_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_transaction_authorization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_permission_authorization(self, seqid, iprot, oprot):
        args = check_permission_authorization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_permission_authorization_result()
        try:
            result.success = self._handler.check_permission_authorization(args.account, args.permission, args.pubkeys_data, args.perms_data, args.delay_us)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_permission_authorization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_permission_last_used(self, seqid, iprot, oprot):
        args = get_permission_last_used_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_permission_last_used_result()
        try:
            result.success = self._handler.get_permission_last_used(args.account, args.permission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_permission_last_used", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_account_creation_time(self, seqid, iprot, oprot):
        args = get_account_creation_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_account_creation_time_result()
        try:
            result.success = self._handler.get_account_creation_time(args.account)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_account_creation_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prints(self, seqid, iprot, oprot):
        args = prints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prints_result()
        try:
            self._handler.prints(args.cstr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prints_l(self, seqid, iprot, oprot):
        args = prints_l_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prints_l_result()
        try:
            self._handler.prints_l(args.cstr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prints_l", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printi(self, seqid, iprot, oprot):
        args = printi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printi_result()
        try:
            self._handler.printi(args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printui(self, seqid, iprot, oprot):
        args = printui_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printui_result()
        try:
            self._handler.printui(args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printui", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printi128(self, seqid, iprot, oprot):
        args = printi128_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printi128_result()
        try:
            self._handler.printi128(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printi128", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printui128(self, seqid, iprot, oprot):
        args = printui128_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printui128_result()
        try:
            self._handler.printui128(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printui128", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printsf(self, seqid, iprot, oprot):
        args = printsf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printsf_result()
        try:
            self._handler.printsf(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printsf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printdf(self, seqid, iprot, oprot):
        args = printdf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printdf_result()
        try:
            self._handler.printdf(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printdf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printqf(self, seqid, iprot, oprot):
        args = printqf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printqf_result()
        try:
            self._handler.printqf(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printqf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printn(self, seqid, iprot, oprot):
        args = printn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printn_result()
        try:
            self._handler.printn(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_printhex(self, seqid, iprot, oprot):
        args = printhex_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = printhex_result()
        try:
            self._handler.printhex(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("printhex", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_action_data_size(self, seqid, iprot, oprot):
        args = action_data_size_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = action_data_size_result()
        try:
            result.success = self._handler.action_data_size()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("action_data_size", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_action_data(self, seqid, iprot, oprot):
        args = read_action_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_action_data_result()
        try:
            result.success = self._handler.read_action_data()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_action_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_require_recipient(self, seqid, iprot, oprot):
        args = require_recipient_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = require_recipient_result()
        try:
            self._handler.require_recipient(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("require_recipient", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_require_auth(self, seqid, iprot, oprot):
        args = require_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = require_auth_result()
        try:
            self._handler.require_auth(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("require_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_auth(self, seqid, iprot, oprot):
        args = has_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_auth_result()
        try:
            result.success = self._handler.has_auth(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("has_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_require_auth2(self, seqid, iprot, oprot):
        args = require_auth2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = require_auth2_result()
        try:
            self._handler.require_auth2(args.name, args.permission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("require_auth2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_account(self, seqid, iprot, oprot):
        args = is_account_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_account_result()
        try:
            result.success = self._handler.is_account(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_account", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_send_inline(self, seqid, iprot, oprot):
        args = send_inline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = send_inline_result()
        try:
            self._handler.send_inline(args.serialized_action)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("send_inline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_send_context_free_inline(self, seqid, iprot, oprot):
        args = send_context_free_inline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = send_context_free_inline_result()
        try:
            self._handler.send_context_free_inline(args.serialized_data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("send_context_free_inline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_publication_time(self, seqid, iprot, oprot):
        args = publication_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = publication_time_result()
        try:
            result.success = self._handler.publication_time()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("publication_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_current_receiver(self, seqid, iprot, oprot):
        args = current_receiver_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = current_receiver_result()
        try:
            result.success = self._handler.current_receiver()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("current_receiver", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_eosio_assert(self, seqid, iprot, oprot):
        args = eosio_assert_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = eosio_assert_result()
        try:
            self._handler.eosio_assert(args.test, args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("eosio_assert", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_eosio_assert_message(self, seqid, iprot, oprot):
        args = eosio_assert_message_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = eosio_assert_message_result()
        try:
            self._handler.eosio_assert_message(args.test, args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("eosio_assert_message", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_eosio_assert_code(self, seqid, iprot, oprot):
        args = eosio_assert_code_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = eosio_assert_code_result()
        try:
            self._handler.eosio_assert_code(args.test, args.code)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("eosio_assert_code", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_eosio_exit(self, seqid, iprot, oprot):
        args = eosio_exit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = eosio_exit_result()
        try:
            self._handler.eosio_exit(args.code)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("eosio_exit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_current_time(self, seqid, iprot, oprot):
        args = current_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = current_time_result()
        try:
            result.success = self._handler.current_time()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("current_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_feature_activated(self, seqid, iprot, oprot):
        args = is_feature_activated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_feature_activated_result()
        try:
            result.success = self._handler.is_feature_activated(args.feature_digest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_feature_activated", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sender(self, seqid, iprot, oprot):
        args = get_sender_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sender_result()
        try:
            result.success = self._handler.get_sender()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sender", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assert_sha256(self, seqid, iprot, oprot):
        args = assert_sha256_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assert_sha256_result()
        try:
            self._handler.assert_sha256(args.data, args.hash)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assert_sha256", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assert_sha1(self, seqid, iprot, oprot):
        args = assert_sha1_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assert_sha1_result()
        try:
            self._handler.assert_sha1(args.data, args.hash)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assert_sha1", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assert_sha512(self, seqid, iprot, oprot):
        args = assert_sha512_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assert_sha512_result()
        try:
            self._handler.assert_sha512(args.data, args.hash)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assert_sha512", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assert_ripemd160(self, seqid, iprot, oprot):
        args = assert_ripemd160_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assert_ripemd160_result()
        try:
            self._handler.assert_ripemd160(args.data, args.hash)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assert_ripemd160", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sha256(self, seqid, iprot, oprot):
        args = sha256_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sha256_result()
        try:
            result.success = self._handler.sha256(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sha256", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sha1(self, seqid, iprot, oprot):
        args = sha1_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sha1_result()
        try:
            result.success = self._handler.sha1(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sha1", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sha512(self, seqid, iprot, oprot):
        args = sha512_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sha512_result()
        try:
            result.success = self._handler.sha512(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sha512", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ripemd160(self, seqid, iprot, oprot):
        args = ripemd160_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ripemd160_result()
        try:
            result.success = self._handler.ripemd160(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ripemd160", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_recover_key(self, seqid, iprot, oprot):
        args = recover_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = recover_key_result()
        try:
            result.success = self._handler.recover_key(args.digest, args.sig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("recover_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assert_recover_key(self, seqid, iprot, oprot):
        args = assert_recover_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assert_recover_key_result()
        try:
            self._handler.assert_recover_key(args.digest, args.sig, args.pub)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assert_recover_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_send_deferred(self, seqid, iprot, oprot):
        args = send_deferred_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = send_deferred_result()
        try:
            self._handler.send_deferred(args.sender_id, args.payer, args.serialized_transaction, args.replace_existing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("send_deferred", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_deferred(self, seqid, iprot, oprot):
        args = cancel_deferred_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_deferred_result()
        try:
            result.success = self._handler.cancel_deferred(args.sender_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_deferred", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_transaction(self, seqid, iprot, oprot):
        args = read_transaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_transaction_result()
        try:
            result.success = self._handler.read_transaction()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_transaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transaction_size(self, seqid, iprot, oprot):
        args = transaction_size_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transaction_size_result()
        try:
            result.success = self._handler.transaction_size()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transaction_size", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tapos_block_num(self, seqid, iprot, oprot):
        args = tapos_block_num_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tapos_block_num_result()
        try:
            result.success = self._handler.tapos_block_num()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tapos_block_num", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tapos_block_prefix(self, seqid, iprot, oprot):
        args = tapos_block_prefix_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tapos_block_prefix_result()
        try:
            result.success = self._handler.tapos_block_prefix()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tapos_block_prefix", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expiration(self, seqid, iprot, oprot):
        args = expiration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expiration_result()
        try:
            result.success = self._handler.expiration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expiration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_action(self, seqid, iprot, oprot):
        args = get_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_action_result()
        try:
            result.success = self._handler.get_action(args._type, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_context_free_data(self, seqid, iprot, oprot):
        args = get_context_free_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_context_free_data_result()
        try:
            result.success = self._handler.get_context_free_data(args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_context_free_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_store_i64(self, seqid, iprot, oprot):
        args = db_store_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_store_i64_result()
        try:
            result.success = self._handler.db_store_i64(args.scope, args.table, args.payer, args.id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_store_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_update_i64(self, seqid, iprot, oprot):
        args = db_update_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_update_i64_result()
        try:
            self._handler.db_update_i64(args.iterator, args.payer, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_update_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_remove_i64(self, seqid, iprot, oprot):
        args = db_remove_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_remove_i64_result()
        try:
            self._handler.db_remove_i64(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_remove_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_get_i64(self, seqid, iprot, oprot):
        args = db_get_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_get_i64_result()
        try:
            result.success = self._handler.db_get_i64(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_get_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_next_i64(self, seqid, iprot, oprot):
        args = db_next_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_next_i64_result()
        try:
            result.success = self._handler.db_next_i64(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_next_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_previous_i64(self, seqid, iprot, oprot):
        args = db_previous_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_previous_i64_result()
        try:
            result.success = self._handler.db_previous_i64(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_previous_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_find_i64(self, seqid, iprot, oprot):
        args = db_find_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_find_i64_result()
        try:
            result.success = self._handler.db_find_i64(args.code, args.scope, args.table, args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_find_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_lowerbound_i64(self, seqid, iprot, oprot):
        args = db_lowerbound_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_lowerbound_i64_result()
        try:
            result.success = self._handler.db_lowerbound_i64(args.code, args.scope, args.table, args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_lowerbound_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_upperbound_i64(self, seqid, iprot, oprot):
        args = db_upperbound_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_upperbound_i64_result()
        try:
            result.success = self._handler.db_upperbound_i64(args.code, args.scope, args.table, args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_upperbound_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_end_i64(self, seqid, iprot, oprot):
        args = db_end_i64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_end_i64_result()
        try:
            result.success = self._handler.db_end_i64(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_end_i64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_store(self, seqid, iprot, oprot):
        args = db_idx64_store_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_store_result()
        try:
            result.success = self._handler.db_idx64_store(args.scope, args.table, args.payer, args.id, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_store", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_update(self, seqid, iprot, oprot):
        args = db_idx64_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_update_result()
        try:
            self._handler.db_idx64_update(args.iterator, args.payer, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_remove(self, seqid, iprot, oprot):
        args = db_idx64_remove_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_remove_result()
        try:
            self._handler.db_idx64_remove(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_remove", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_next(self, seqid, iprot, oprot):
        args = db_idx64_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_next_result()
        try:
            result.success = self._handler.db_idx64_next(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_previous(self, seqid, iprot, oprot):
        args = db_idx64_previous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_previous_result()
        try:
            result.success = self._handler.db_idx64_previous(args.iteratory)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_previous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_find_primary(self, seqid, iprot, oprot):
        args = db_idx64_find_primary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_find_primary_result()
        try:
            result.success = self._handler.db_idx64_find_primary(args.code, args.scope, args.table, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_find_primary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_find_secondary(self, seqid, iprot, oprot):
        args = db_idx64_find_secondary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_find_secondary_result()
        try:
            result.success = self._handler.db_idx64_find_secondary(args.code, args.scope, args.table, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_find_secondary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_lowerbound(self, seqid, iprot, oprot):
        args = db_idx64_lowerbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_lowerbound_result()
        try:
            result.success = self._handler.db_idx64_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_lowerbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_upperbound(self, seqid, iprot, oprot):
        args = db_idx64_upperbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_upperbound_result()
        try:
            result.success = self._handler.db_idx64_upperbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_upperbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx64_end(self, seqid, iprot, oprot):
        args = db_idx64_end_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx64_end_result()
        try:
            result.success = self._handler.db_idx64_end(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx64_end", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_store(self, seqid, iprot, oprot):
        args = db_idx128_store_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_store_result()
        try:
            result.success = self._handler.db_idx128_store(args.scope, args.table, args.payer, args.id, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_store", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_update(self, seqid, iprot, oprot):
        args = db_idx128_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_update_result()
        try:
            self._handler.db_idx128_update(args.iterator, args.payer, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_remove(self, seqid, iprot, oprot):
        args = db_idx128_remove_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_remove_result()
        try:
            self._handler.db_idx128_remove(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_remove", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_next(self, seqid, iprot, oprot):
        args = db_idx128_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_next_result()
        try:
            result.success = self._handler.db_idx128_next(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_previous(self, seqid, iprot, oprot):
        args = db_idx128_previous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_previous_result()
        try:
            result.success = self._handler.db_idx128_previous(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_previous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_find_primary(self, seqid, iprot, oprot):
        args = db_idx128_find_primary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_find_primary_result()
        try:
            result.success = self._handler.db_idx128_find_primary(args.code, args.scope, args.table, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_find_primary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_find_secondary(self, seqid, iprot, oprot):
        args = db_idx128_find_secondary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_find_secondary_result()
        try:
            result.success = self._handler.db_idx128_find_secondary(args.code, args.scope, args.table, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_find_secondary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_lowerbound(self, seqid, iprot, oprot):
        args = db_idx128_lowerbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_lowerbound_result()
        try:
            result.success = self._handler.db_idx128_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_lowerbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_upperbound(self, seqid, iprot, oprot):
        args = db_idx128_upperbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_upperbound_result()
        try:
            result.success = self._handler.db_idx128_upperbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_upperbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx128_end(self, seqid, iprot, oprot):
        args = db_idx128_end_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx128_end_result()
        try:
            result.success = self._handler.db_idx128_end(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx128_end", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_store(self, seqid, iprot, oprot):
        args = db_idx256_store_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_store_result()
        try:
            result.success = self._handler.db_idx256_store(args.scope, args.table, args.payer, args.id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_store", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_update(self, seqid, iprot, oprot):
        args = db_idx256_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_update_result()
        try:
            self._handler.db_idx256_update(args.iterator, args.payer, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_remove(self, seqid, iprot, oprot):
        args = db_idx256_remove_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_remove_result()
        try:
            self._handler.db_idx256_remove(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_remove", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_next(self, seqid, iprot, oprot):
        args = db_idx256_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_next_result()
        try:
            result.success = self._handler.db_idx256_next(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_previous(self, seqid, iprot, oprot):
        args = db_idx256_previous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_previous_result()
        try:
            result.success = self._handler.db_idx256_previous(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_previous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_find_primary(self, seqid, iprot, oprot):
        args = db_idx256_find_primary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_find_primary_result()
        try:
            result.success = self._handler.db_idx256_find_primary(args.code, args.scope, args.table, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_find_primary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_find_secondary(self, seqid, iprot, oprot):
        args = db_idx256_find_secondary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_find_secondary_result()
        try:
            result.success = self._handler.db_idx256_find_secondary(args.code, args.scope, args.table, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_find_secondary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_lowerbound(self, seqid, iprot, oprot):
        args = db_idx256_lowerbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_lowerbound_result()
        try:
            result.success = self._handler.db_idx256_lowerbound(args.code, args.scope, args.table, args.data, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_lowerbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_upperbound(self, seqid, iprot, oprot):
        args = db_idx256_upperbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_upperbound_result()
        try:
            result.success = self._handler.db_idx256_upperbound(args.code, args.scope, args.table, args.data, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_upperbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx256_end(self, seqid, iprot, oprot):
        args = db_idx256_end_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx256_end_result()
        try:
            result.success = self._handler.db_idx256_end(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx256_end", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_store(self, seqid, iprot, oprot):
        args = db_idx_double_store_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_store_result()
        try:
            result.success = self._handler.db_idx_double_store(args.scope, args.table, args.payer, args.id, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_store", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_update(self, seqid, iprot, oprot):
        args = db_idx_double_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_update_result()
        try:
            self._handler.db_idx_double_update(args.iterator, args.payer, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_remove(self, seqid, iprot, oprot):
        args = db_idx_double_remove_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_remove_result()
        try:
            self._handler.db_idx_double_remove(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_remove", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_next(self, seqid, iprot, oprot):
        args = db_idx_double_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_next_result()
        try:
            result.success = self._handler.db_idx_double_next(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_previous(self, seqid, iprot, oprot):
        args = db_idx_double_previous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_previous_result()
        try:
            result.success = self._handler.db_idx_double_previous(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_previous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_find_primary(self, seqid, iprot, oprot):
        args = db_idx_double_find_primary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_find_primary_result()
        try:
            result.success = self._handler.db_idx_double_find_primary(args.code, args.scope, args.table, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_find_primary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_find_secondary(self, seqid, iprot, oprot):
        args = db_idx_double_find_secondary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_find_secondary_result()
        try:
            result.success = self._handler.db_idx_double_find_secondary(args.code, args.scope, args.table, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_find_secondary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_lowerbound(self, seqid, iprot, oprot):
        args = db_idx_double_lowerbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_lowerbound_result()
        try:
            result.success = self._handler.db_idx_double_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_lowerbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_upperbound(self, seqid, iprot, oprot):
        args = db_idx_double_upperbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_upperbound_result()
        try:
            result.success = self._handler.db_idx_double_upperbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_upperbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_double_end(self, seqid, iprot, oprot):
        args = db_idx_double_end_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_double_end_result()
        try:
            result.success = self._handler.db_idx_double_end(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_double_end", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_store(self, seqid, iprot, oprot):
        args = db_idx_long_double_store_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_store_result()
        try:
            result.success = self._handler.db_idx_long_double_store(args.scope, args.table, args.payer, args.id, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_store", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_update(self, seqid, iprot, oprot):
        args = db_idx_long_double_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_update_result()
        try:
            self._handler.db_idx_long_double_update(args.iterator, args.payer, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_remove(self, seqid, iprot, oprot):
        args = db_idx_long_double_remove_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_remove_result()
        try:
            self._handler.db_idx_long_double_remove(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_remove", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_next(self, seqid, iprot, oprot):
        args = db_idx_long_double_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_next_result()
        try:
            result.success = self._handler.db_idx_long_double_next(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_previous(self, seqid, iprot, oprot):
        args = db_idx_long_double_previous_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_previous_result()
        try:
            result.success = self._handler.db_idx_long_double_previous(args.iterator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_previous", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_find_primary(self, seqid, iprot, oprot):
        args = db_idx_long_double_find_primary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_find_primary_result()
        try:
            result.success = self._handler.db_idx_long_double_find_primary(args.code, args.scope, args.table, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_find_primary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_find_secondary(self, seqid, iprot, oprot):
        args = db_idx_long_double_find_secondary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_find_secondary_result()
        try:
            result.success = self._handler.db_idx_long_double_find_secondary(args.code, args.scope, args.table, args.secondary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_find_secondary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_lowerbound(self, seqid, iprot, oprot):
        args = db_idx_long_double_lowerbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_lowerbound_result()
        try:
            result.success = self._handler.db_idx_long_double_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_lowerbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_upperbound(self, seqid, iprot, oprot):
        args = db_idx_long_double_upperbound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_upperbound_result()
        try:
            result.success = self._handler.db_idx_long_double_upperbound(args.code, args.scope, args.table, args.secondary, args.primary)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_upperbound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_db_idx_long_double_end(self, seqid, iprot, oprot):
        args = db_idx_long_double_end_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = db_idx_long_double_end_result()
        try:
            result.success = self._handler.db_idx_long_double_end(args.code, args.scope, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("db_idx_long_double_end", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_action_return_value(self, seqid, iprot, oprot):
        args = set_action_return_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_action_return_value_result()
        try:
            self._handler.set_action_return_value(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_action_return_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_code_hash(self, seqid, iprot, oprot):
        args = get_code_hash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_code_hash_result()
        try:
            result.success = self._handler.get_code_hash(args.account, args.struct_version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_code_hash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_block_num(self, seqid, iprot, oprot):
        args = get_block_num_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_block_num_result()
        try:
            result.success = self._handler.get_block_num()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_block_num", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sha3(self, seqid, iprot, oprot):
        args = sha3_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sha3_result()
        try:
            result.success = self._handler.sha3(args.data, args.keccak)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sha3", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_blake2_f(self, seqid, iprot, oprot):
        args = blake2_f_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blake2_f_result()
        try:
            result.success = self._handler.blake2_f(args.rounds, args.state, args.msg, args.t0_offset, args.t1_offset, args.final)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("blake2_f", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_k1_recover(self, seqid, iprot, oprot):
        args = k1_recover_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = k1_recover_result()
        try:
            result.success = self._handler.k1_recover(args.sig, args.dig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("k1_recover", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alt_bn128_add(self, seqid, iprot, oprot):
        args = alt_bn128_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alt_bn128_add_result()
        try:
            result.success = self._handler.alt_bn128_add(args.op1, args.op2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alt_bn128_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alt_bn128_mul(self, seqid, iprot, oprot):
        args = alt_bn128_mul_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alt_bn128_mul_result()
        try:
            result.success = self._handler.alt_bn128_mul(args.g1, args.scalar)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alt_bn128_mul", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alt_bn128_pair(self, seqid, iprot, oprot):
        args = alt_bn128_pair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alt_bn128_pair_result()
        try:
            result.success = self._handler.alt_bn128_pair(args.pairs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alt_bn128_pair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mod_exp(self, seqid, iprot, oprot):
        args = mod_exp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mod_exp_result()
        try:
            result.success = self._handler.mod_exp(args.base, args.exp, args.mod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mod_exp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class end_apply_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_apply_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_apply_args)
end_apply_args.thrift_spec = (
)


class end_apply_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_apply_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_apply_result)
end_apply_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_active_producers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_producers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_producers_args)
get_active_producers_args.thrift_spec = (
)


class get_active_producers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_active_producers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_active_producers_result)
get_active_producers_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class get_resource_limits_args(object):
    """
    Attributes:
     - account

    """


    def __init__(self, account=None,):
        self.account = account

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_resource_limits_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_resource_limits_args)
get_resource_limits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
)


class get_resource_limits_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetResourceLimitsReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_resource_limits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_resource_limits_result)
get_resource_limits_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [GetResourceLimitsReturn, None], None, ),  # 0
)


class set_resource_limits_args(object):
    """
    Attributes:
     - account
     - ram_bytes
     - net_weight
     - cpu_weight

    """


    def __init__(self, account=None, ram_bytes=None, net_weight=None, cpu_weight=None,):
        self.account = account
        self.ram_bytes = ram_bytes
        self.net_weight = net_weight
        self.cpu_weight = cpu_weight

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ram_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.net_weight = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.cpu_weight = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_resource_limits_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        if self.ram_bytes is not None:
            oprot.writeFieldBegin('ram_bytes', TType.I64, 2)
            oprot.writeI64(self.ram_bytes)
            oprot.writeFieldEnd()
        if self.net_weight is not None:
            oprot.writeFieldBegin('net_weight', TType.I64, 3)
            oprot.writeI64(self.net_weight)
            oprot.writeFieldEnd()
        if self.cpu_weight is not None:
            oprot.writeFieldBegin('cpu_weight', TType.I64, 4)
            oprot.writeI64(self.cpu_weight)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_resource_limits_args)
set_resource_limits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
    (2, TType.I64, 'ram_bytes', None, None, ),  # 2
    (3, TType.I64, 'net_weight', None, None, ),  # 3
    (4, TType.I64, 'cpu_weight', None, None, ),  # 4
)


class set_resource_limits_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_resource_limits_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_resource_limits_result)
set_resource_limits_result.thrift_spec = (
)


class set_proposed_producers_args(object):
    """
    Attributes:
     - producer_data

    """


    def __init__(self, producer_data=None,):
        self.producer_data = producer_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.producer_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_proposed_producers_args')
        if self.producer_data is not None:
            oprot.writeFieldBegin('producer_data', TType.STRING, 1)
            oprot.writeBinary(self.producer_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_proposed_producers_args)
set_proposed_producers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'producer_data', 'BINARY', None, ),  # 1
)


class set_proposed_producers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_proposed_producers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_proposed_producers_result)
set_proposed_producers_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class set_proposed_producers_ex_args(object):
    """
    Attributes:
     - producer_data_format
     - producer_data

    """


    def __init__(self, producer_data_format=None, producer_data=None,):
        self.producer_data_format = producer_data_format
        self.producer_data = producer_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.producer_data_format = Uint64()
                    self.producer_data_format.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.producer_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_proposed_producers_ex_args')
        if self.producer_data_format is not None:
            oprot.writeFieldBegin('producer_data_format', TType.STRUCT, 1)
            self.producer_data_format.write(oprot)
            oprot.writeFieldEnd()
        if self.producer_data is not None:
            oprot.writeFieldBegin('producer_data', TType.STRING, 2)
            oprot.writeBinary(self.producer_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_proposed_producers_ex_args)
set_proposed_producers_ex_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'producer_data_format', [Uint64, None], None, ),  # 1
    (2, TType.STRING, 'producer_data', 'BINARY', None, ),  # 2
)


class set_proposed_producers_ex_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_proposed_producers_ex_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_proposed_producers_ex_result)
set_proposed_producers_ex_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class is_privileged_args(object):
    """
    Attributes:
     - account

    """


    def __init__(self, account=None,):
        self.account = account

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_privileged_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_privileged_args)
is_privileged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
)


class is_privileged_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_privileged_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_privileged_result)
is_privileged_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class set_privileged_args(object):
    """
    Attributes:
     - account
     - is_priv

    """


    def __init__(self, account=None, is_priv=None,):
        self.account = account
        self.is_priv = is_priv

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_priv = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_privileged_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        if self.is_priv is not None:
            oprot.writeFieldBegin('is_priv', TType.BOOL, 2)
            oprot.writeBool(self.is_priv)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_privileged_args)
set_privileged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
    (2, TType.BOOL, 'is_priv', None, None, ),  # 2
)


class set_privileged_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_privileged_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_privileged_result)
set_privileged_result.thrift_spec = (
)


class set_blockchain_parameters_packed_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_blockchain_parameters_packed_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_blockchain_parameters_packed_args)
set_blockchain_parameters_packed_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class set_blockchain_parameters_packed_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_blockchain_parameters_packed_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_blockchain_parameters_packed_result)
set_blockchain_parameters_packed_result.thrift_spec = (
)


class get_blockchain_parameters_packed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_blockchain_parameters_packed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_blockchain_parameters_packed_args)
get_blockchain_parameters_packed_args.thrift_spec = (
)


class get_blockchain_parameters_packed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_blockchain_parameters_packed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_blockchain_parameters_packed_result)
get_blockchain_parameters_packed_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class preactivate_feature_args(object):
    """
    Attributes:
     - feature_digest

    """


    def __init__(self, feature_digest=None,):
        self.feature_digest = feature_digest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.feature_digest = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('preactivate_feature_args')
        if self.feature_digest is not None:
            oprot.writeFieldBegin('feature_digest', TType.STRING, 1)
            oprot.writeBinary(self.feature_digest)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(preactivate_feature_args)
preactivate_feature_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'feature_digest', 'BINARY', None, ),  # 1
)


class preactivate_feature_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('preactivate_feature_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(preactivate_feature_result)
preactivate_feature_result.thrift_spec = (
)


class check_transaction_authorization_args(object):
    """
    Attributes:
     - trx_data
     - pubkeys_data
     - perms_data

    """


    def __init__(self, trx_data=None, pubkeys_data=None, perms_data=None,):
        self.trx_data = trx_data
        self.pubkeys_data = pubkeys_data
        self.perms_data = perms_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.trx_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pubkeys_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.perms_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_transaction_authorization_args')
        if self.trx_data is not None:
            oprot.writeFieldBegin('trx_data', TType.STRING, 1)
            oprot.writeBinary(self.trx_data)
            oprot.writeFieldEnd()
        if self.pubkeys_data is not None:
            oprot.writeFieldBegin('pubkeys_data', TType.STRING, 2)
            oprot.writeBinary(self.pubkeys_data)
            oprot.writeFieldEnd()
        if self.perms_data is not None:
            oprot.writeFieldBegin('perms_data', TType.STRING, 3)
            oprot.writeBinary(self.perms_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_transaction_authorization_args)
check_transaction_authorization_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'trx_data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'pubkeys_data', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'perms_data', 'BINARY', None, ),  # 3
)


class check_transaction_authorization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_transaction_authorization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_transaction_authorization_result)
check_transaction_authorization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class check_permission_authorization_args(object):
    """
    Attributes:
     - account
     - permission
     - pubkeys_data
     - perms_data
     - delay_us

    """


    def __init__(self, account=None, permission=None, pubkeys_data=None, perms_data=None, delay_us=None,):
        self.account = account
        self.permission = permission
        self.pubkeys_data = pubkeys_data
        self.perms_data = perms_data
        self.delay_us = delay_us

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.permission = Uint64()
                    self.permission.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pubkeys_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.perms_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.delay_us = Uint64()
                    self.delay_us.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_permission_authorization_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.STRUCT, 2)
            self.permission.write(oprot)
            oprot.writeFieldEnd()
        if self.pubkeys_data is not None:
            oprot.writeFieldBegin('pubkeys_data', TType.STRING, 3)
            oprot.writeBinary(self.pubkeys_data)
            oprot.writeFieldEnd()
        if self.perms_data is not None:
            oprot.writeFieldBegin('perms_data', TType.STRING, 4)
            oprot.writeBinary(self.perms_data)
            oprot.writeFieldEnd()
        if self.delay_us is not None:
            oprot.writeFieldBegin('delay_us', TType.STRUCT, 5)
            self.delay_us.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_permission_authorization_args)
check_permission_authorization_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'permission', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'pubkeys_data', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'perms_data', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'delay_us', [Uint64, None], None, ),  # 5
)


class check_permission_authorization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_permission_authorization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_permission_authorization_result)
check_permission_authorization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_permission_last_used_args(object):
    """
    Attributes:
     - account
     - permission

    """


    def __init__(self, account=None, permission=None,):
        self.account = account
        self.permission = permission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.permission = Uint64()
                    self.permission.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_permission_last_used_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.STRUCT, 2)
            self.permission.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_permission_last_used_args)
get_permission_last_used_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'permission', [Uint64, None], None, ),  # 2
)


class get_permission_last_used_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_permission_last_used_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_permission_last_used_result)
get_permission_last_used_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class get_account_creation_time_args(object):
    """
    Attributes:
     - account

    """


    def __init__(self, account=None,):
        self.account = account

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_account_creation_time_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_account_creation_time_args)
get_account_creation_time_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
)


class get_account_creation_time_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_account_creation_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_account_creation_time_result)
get_account_creation_time_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class prints_args(object):
    """
    Attributes:
     - cstr

    """


    def __init__(self, cstr=None,):
        self.cstr = cstr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cstr = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prints_args')
        if self.cstr is not None:
            oprot.writeFieldBegin('cstr', TType.STRING, 1)
            oprot.writeString(self.cstr.encode('utf-8') if sys.version_info[0] == 2 else self.cstr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prints_args)
prints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cstr', 'UTF8', None, ),  # 1
)


class prints_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prints_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prints_result)
prints_result.thrift_spec = (
)


class prints_l_args(object):
    """
    Attributes:
     - cstr

    """


    def __init__(self, cstr=None,):
        self.cstr = cstr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cstr = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prints_l_args')
        if self.cstr is not None:
            oprot.writeFieldBegin('cstr', TType.STRING, 1)
            oprot.writeBinary(self.cstr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prints_l_args)
prints_l_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cstr', 'BINARY', None, ),  # 1
)


class prints_l_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prints_l_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prints_l_result)
prints_l_result.thrift_spec = (
)


class printi_args(object):
    """
    Attributes:
     - n

    """


    def __init__(self, n=None,):
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.n = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printi_args')
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I64, 1)
            oprot.writeI64(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printi_args)
printi_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'n', None, None, ),  # 1
)


class printi_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printi_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printi_result)
printi_result.thrift_spec = (
)


class printui_args(object):
    """
    Attributes:
     - n

    """


    def __init__(self, n=None,):
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.n = Uint64()
                    self.n.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printui_args')
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.STRUCT, 1)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printui_args)
printui_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'n', [Uint64, None], None, ),  # 1
)


class printui_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printui_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printui_result)
printui_result.thrift_spec = (
)


class printi128_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printi128_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printi128_args)
printi128_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)


class printi128_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printi128_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printi128_result)
printi128_result.thrift_spec = (
)


class printui128_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printui128_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printui128_args)
printui128_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)


class printui128_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printui128_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printui128_result)
printui128_result.thrift_spec = (
)


class printsf_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printsf_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printsf_args)
printsf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)


class printsf_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printsf_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printsf_result)
printsf_result.thrift_spec = (
)


class printdf_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printdf_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printdf_args)
printdf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)


class printdf_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printdf_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printdf_result)
printdf_result.thrift_spec = (
)


class printqf_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printqf_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printqf_args)
printqf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)


class printqf_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printqf_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printqf_result)
printqf_result.thrift_spec = (
)


class printn_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printn_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printn_args)
printn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
)


class printn_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printn_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printn_result)
printn_result.thrift_spec = (
)


class printhex_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printhex_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printhex_args)
printhex_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class printhex_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('printhex_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(printhex_result)
printhex_result.thrift_spec = (
)


class action_data_size_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('action_data_size_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(action_data_size_args)
action_data_size_args.thrift_spec = (
)


class action_data_size_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('action_data_size_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(action_data_size_result)
action_data_size_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_action_data_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_action_data_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_action_data_args)
read_action_data_args.thrift_spec = (
)


class read_action_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_action_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_action_data_result)
read_action_data_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class require_recipient_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_recipient_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_recipient_args)
require_recipient_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
)


class require_recipient_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_recipient_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_recipient_result)
require_recipient_result.thrift_spec = (
)


class require_auth_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_auth_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_auth_args)
require_auth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
)


class require_auth_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_auth_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_auth_result)
require_auth_result.thrift_spec = (
)


class has_auth_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_auth_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_auth_args)
has_auth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
)


class has_auth_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('has_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(has_auth_result)
has_auth_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class require_auth2_args(object):
    """
    Attributes:
     - name
     - permission

    """


    def __init__(self, name=None, permission=None,):
        self.name = name
        self.permission = permission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.permission = Uint64()
                    self.permission.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_auth2_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.STRUCT, 2)
            self.permission.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_auth2_args)
require_auth2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'permission', [Uint64, None], None, ),  # 2
)


class require_auth2_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('require_auth2_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(require_auth2_result)
require_auth2_result.thrift_spec = (
)


class is_account_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.name = Uint64()
                    self.name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_account_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRUCT, 1)
            self.name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_account_args)
is_account_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'name', [Uint64, None], None, ),  # 1
)


class is_account_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_account_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_account_result)
is_account_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class send_inline_args(object):
    """
    Attributes:
     - serialized_action

    """


    def __init__(self, serialized_action=None,):
        self.serialized_action = serialized_action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serialized_action = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_inline_args')
        if self.serialized_action is not None:
            oprot.writeFieldBegin('serialized_action', TType.STRING, 1)
            oprot.writeBinary(self.serialized_action)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_inline_args)
send_inline_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serialized_action', 'BINARY', None, ),  # 1
)


class send_inline_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_inline_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_inline_result)
send_inline_result.thrift_spec = (
)


class send_context_free_inline_args(object):
    """
    Attributes:
     - serialized_data

    """


    def __init__(self, serialized_data=None,):
        self.serialized_data = serialized_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.serialized_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_context_free_inline_args')
        if self.serialized_data is not None:
            oprot.writeFieldBegin('serialized_data', TType.STRING, 1)
            oprot.writeBinary(self.serialized_data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_context_free_inline_args)
send_context_free_inline_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'serialized_data', 'BINARY', None, ),  # 1
)


class send_context_free_inline_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_context_free_inline_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_context_free_inline_result)
send_context_free_inline_result.thrift_spec = (
)


class publication_time_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('publication_time_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(publication_time_args)
publication_time_args.thrift_spec = (
)


class publication_time_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Uint64()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('publication_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(publication_time_result)
publication_time_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Uint64, None], None, ),  # 0
)


class current_receiver_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('current_receiver_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(current_receiver_args)
current_receiver_args.thrift_spec = (
)


class current_receiver_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Uint64()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('current_receiver_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(current_receiver_result)
current_receiver_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Uint64, None], None, ),  # 0
)


class eosio_assert_args(object):
    """
    Attributes:
     - test
     - msg

    """


    def __init__(self, test=None, msg=None,):
        self.test = test
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.test = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msg = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_args')
        if self.test is not None:
            oprot.writeFieldBegin('test', TType.BOOL, 1)
            oprot.writeBool(self.test)
            oprot.writeFieldEnd()
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRING, 2)
            oprot.writeBinary(self.msg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_args)
eosio_assert_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'test', None, None, ),  # 1
    (2, TType.STRING, 'msg', 'BINARY', None, ),  # 2
)


class eosio_assert_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_result)
eosio_assert_result.thrift_spec = (
)


class eosio_assert_message_args(object):
    """
    Attributes:
     - test
     - msg

    """


    def __init__(self, test=None, msg=None,):
        self.test = test
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.test = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msg = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_message_args')
        if self.test is not None:
            oprot.writeFieldBegin('test', TType.BOOL, 1)
            oprot.writeBool(self.test)
            oprot.writeFieldEnd()
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRING, 2)
            oprot.writeBinary(self.msg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_message_args)
eosio_assert_message_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'test', None, None, ),  # 1
    (2, TType.STRING, 'msg', 'BINARY', None, ),  # 2
)


class eosio_assert_message_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_message_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_message_result)
eosio_assert_message_result.thrift_spec = (
)


class eosio_assert_code_args(object):
    """
    Attributes:
     - test
     - code

    """


    def __init__(self, test=None, code=None,):
        self.test = test
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.test = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_code_args')
        if self.test is not None:
            oprot.writeFieldBegin('test', TType.BOOL, 1)
            oprot.writeBool(self.test)
            oprot.writeFieldEnd()
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 2)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_code_args)
eosio_assert_code_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'test', None, None, ),  # 1
    (2, TType.STRUCT, 'code', [Uint64, None], None, ),  # 2
)


class eosio_assert_code_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_assert_code_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_assert_code_result)
eosio_assert_code_result.thrift_spec = (
)


class eosio_exit_args(object):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_exit_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_exit_args)
eosio_exit_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)


class eosio_exit_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('eosio_exit_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(eosio_exit_result)
eosio_exit_result.thrift_spec = (
)


class current_time_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('current_time_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(current_time_args)
current_time_args.thrift_spec = (
)


class current_time_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Uint64()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('current_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(current_time_result)
current_time_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Uint64, None], None, ),  # 0
)


class is_feature_activated_args(object):
    """
    Attributes:
     - feature_digest

    """


    def __init__(self, feature_digest=None,):
        self.feature_digest = feature_digest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.feature_digest = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_feature_activated_args')
        if self.feature_digest is not None:
            oprot.writeFieldBegin('feature_digest', TType.STRING, 1)
            oprot.writeBinary(self.feature_digest)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_feature_activated_args)
is_feature_activated_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'feature_digest', 'BINARY', None, ),  # 1
)


class is_feature_activated_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_feature_activated_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_feature_activated_result)
is_feature_activated_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_sender_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sender_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sender_args)
get_sender_args.thrift_spec = (
)


class get_sender_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Uint64()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sender_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sender_result)
get_sender_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Uint64, None], None, ),  # 0
)


class assert_sha256_args(object):
    """
    Attributes:
     - data
     - hash

    """


    def __init__(self, data=None, hash=None,):
        self.data = data
        self.hash = hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha256_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeBinary(self.hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha256_args)
assert_sha256_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'hash', 'BINARY', None, ),  # 2
)


class assert_sha256_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha256_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha256_result)
assert_sha256_result.thrift_spec = (
)


class assert_sha1_args(object):
    """
    Attributes:
     - data
     - hash

    """


    def __init__(self, data=None, hash=None,):
        self.data = data
        self.hash = hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha1_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeBinary(self.hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha1_args)
assert_sha1_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'hash', 'BINARY', None, ),  # 2
)


class assert_sha1_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha1_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha1_result)
assert_sha1_result.thrift_spec = (
)


class assert_sha512_args(object):
    """
    Attributes:
     - data
     - hash

    """


    def __init__(self, data=None, hash=None,):
        self.data = data
        self.hash = hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha512_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeBinary(self.hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha512_args)
assert_sha512_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'hash', 'BINARY', None, ),  # 2
)


class assert_sha512_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_sha512_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_sha512_result)
assert_sha512_result.thrift_spec = (
)


class assert_ripemd160_args(object):
    """
    Attributes:
     - data
     - hash

    """


    def __init__(self, data=None, hash=None,):
        self.data = data
        self.hash = hash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_ripemd160_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeBinary(self.hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_ripemd160_args)
assert_ripemd160_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'hash', 'BINARY', None, ),  # 2
)


class assert_ripemd160_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_ripemd160_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_ripemd160_result)
assert_ripemd160_result.thrift_spec = (
)


class sha256_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha256_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha256_args)
sha256_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class sha256_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha256_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha256_result)
sha256_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class sha1_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha1_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha1_args)
sha1_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class sha1_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha1_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha1_result)
sha1_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class sha512_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha512_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha512_args)
sha512_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class sha512_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha512_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha512_result)
sha512_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class ripemd160_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ripemd160_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ripemd160_args)
ripemd160_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class ripemd160_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ripemd160_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ripemd160_result)
ripemd160_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class recover_key_args(object):
    """
    Attributes:
     - digest
     - sig

    """


    def __init__(self, digest=None, sig=None,):
        self.digest = digest
        self.sig = sig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.digest = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sig = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recover_key_args')
        if self.digest is not None:
            oprot.writeFieldBegin('digest', TType.STRING, 1)
            oprot.writeBinary(self.digest)
            oprot.writeFieldEnd()
        if self.sig is not None:
            oprot.writeFieldBegin('sig', TType.STRING, 2)
            oprot.writeBinary(self.sig)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recover_key_args)
recover_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'digest', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'sig', 'BINARY', None, ),  # 2
)


class recover_key_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recover_key_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recover_key_result)
recover_key_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class assert_recover_key_args(object):
    """
    Attributes:
     - digest
     - sig
     - pub

    """


    def __init__(self, digest=None, sig=None, pub=None,):
        self.digest = digest
        self.sig = sig
        self.pub = pub

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.digest = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sig = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pub = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_recover_key_args')
        if self.digest is not None:
            oprot.writeFieldBegin('digest', TType.STRING, 1)
            oprot.writeBinary(self.digest)
            oprot.writeFieldEnd()
        if self.sig is not None:
            oprot.writeFieldBegin('sig', TType.STRING, 2)
            oprot.writeBinary(self.sig)
            oprot.writeFieldEnd()
        if self.pub is not None:
            oprot.writeFieldBegin('pub', TType.STRING, 3)
            oprot.writeBinary(self.pub)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_recover_key_args)
assert_recover_key_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'digest', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'sig', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'pub', 'BINARY', None, ),  # 3
)


class assert_recover_key_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assert_recover_key_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assert_recover_key_result)
assert_recover_key_result.thrift_spec = (
)


class send_deferred_args(object):
    """
    Attributes:
     - sender_id
     - payer
     - serialized_transaction
     - replace_existing

    """


    def __init__(self, sender_id=None, payer=None, serialized_transaction=None, replace_existing=None,):
        self.sender_id = sender_id
        self.payer = payer
        self.serialized_transaction = serialized_transaction
        self.replace_existing = replace_existing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sender_id = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.serialized_transaction = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.replace_existing = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_deferred_args')
        if self.sender_id is not None:
            oprot.writeFieldBegin('sender_id', TType.STRING, 1)
            oprot.writeBinary(self.sender_id)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.serialized_transaction is not None:
            oprot.writeFieldBegin('serialized_transaction', TType.STRING, 3)
            oprot.writeBinary(self.serialized_transaction)
            oprot.writeFieldEnd()
        if self.replace_existing is not None:
            oprot.writeFieldBegin('replace_existing', TType.I32, 4)
            oprot.writeI32(self.replace_existing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_deferred_args)
send_deferred_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sender_id', 'BINARY', None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'serialized_transaction', 'BINARY', None, ),  # 3
    (4, TType.I32, 'replace_existing', None, None, ),  # 4
)


class send_deferred_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('send_deferred_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(send_deferred_result)
send_deferred_result.thrift_spec = (
)


class cancel_deferred_args(object):
    """
    Attributes:
     - sender_id

    """


    def __init__(self, sender_id=None,):
        self.sender_id = sender_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sender_id = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_deferred_args')
        if self.sender_id is not None:
            oprot.writeFieldBegin('sender_id', TType.STRING, 1)
            oprot.writeBinary(self.sender_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_deferred_args)
cancel_deferred_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sender_id', 'BINARY', None, ),  # 1
)


class cancel_deferred_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_deferred_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_deferred_result)
cancel_deferred_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_transaction_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_transaction_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_transaction_args)
read_transaction_args.thrift_spec = (
)


class read_transaction_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_transaction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_transaction_result)
read_transaction_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class transaction_size_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transaction_size_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transaction_size_args)
transaction_size_args.thrift_spec = (
)


class transaction_size_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transaction_size_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transaction_size_result)
transaction_size_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tapos_block_num_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tapos_block_num_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tapos_block_num_args)
tapos_block_num_args.thrift_spec = (
)


class tapos_block_num_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tapos_block_num_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tapos_block_num_result)
tapos_block_num_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tapos_block_prefix_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tapos_block_prefix_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tapos_block_prefix_args)
tapos_block_prefix_args.thrift_spec = (
)


class tapos_block_prefix_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tapos_block_prefix_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tapos_block_prefix_result)
tapos_block_prefix_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class expiration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expiration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expiration_args)
expiration_args.thrift_spec = (
)


class expiration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expiration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expiration_result)
expiration_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class get_action_args(object):
    """
    Attributes:
     - _type
     - index

    """


    def __init__(self, _type=None, index=None,):
        self._type = _type
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self._type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_action_args')
        if self._type is not None:
            oprot.writeFieldBegin('_type', TType.I32, 1)
            oprot.writeI32(self._type)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 2)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_action_args)
get_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, '_type', None, None, ),  # 1
    (2, TType.I32, 'index', None, None, ),  # 2
)


class get_action_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_action_result)
get_action_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class get_context_free_data_args(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_context_free_data_args')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_context_free_data_args)
get_context_free_data_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)


class get_context_free_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_context_free_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_context_free_data_result)
get_context_free_data_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class db_store_i64_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - data

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, data=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_store_i64_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 5)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_store_i64_args)
db_store_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRING, 'data', 'BINARY', None, ),  # 5
)


class db_store_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_store_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_store_i64_result)
db_store_i64_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_update_i64_args(object):
    """
    Attributes:
     - iterator
     - payer
     - data

    """


    def __init__(self, iterator=None, payer=None, data=None,):
        self.iterator = iterator
        self.payer = payer
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_update_i64_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_update_i64_args)
db_update_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
)


class db_update_i64_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_update_i64_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_update_i64_result)
db_update_i64_result.thrift_spec = (
)


class db_remove_i64_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_remove_i64_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_remove_i64_args)
db_remove_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_remove_i64_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_remove_i64_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_remove_i64_result)
db_remove_i64_result.thrift_spec = (
)


class db_get_i64_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_get_i64_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_get_i64_args)
db_get_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_get_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_get_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_get_i64_result)
db_get_i64_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class db_next_i64_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_next_i64_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_next_i64_args)
db_next_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_next_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_next_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_next_i64_result)
db_next_i64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_previous_i64_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_previous_i64_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_previous_i64_args)
db_previous_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_previous_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_previous_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_previous_i64_result)
db_previous_i64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_find_i64_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - id

    """


    def __init__(self, code=None, scope=None, table=None, id=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_find_i64_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_find_i64_args)
db_find_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
)


class db_find_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_find_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_find_i64_result)
db_find_i64_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_lowerbound_i64_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - id

    """


    def __init__(self, code=None, scope=None, table=None, id=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_lowerbound_i64_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_lowerbound_i64_args)
db_lowerbound_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
)


class db_lowerbound_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_lowerbound_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_lowerbound_i64_result)
db_lowerbound_i64_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_upperbound_i64_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - id

    """


    def __init__(self, code=None, scope=None, table=None, id=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_upperbound_i64_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_upperbound_i64_args)
db_upperbound_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
)


class db_upperbound_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_upperbound_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_upperbound_i64_result)
db_upperbound_i64_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_end_i64_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_end_i64_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_end_i64_args)
db_end_i64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_end_i64_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_end_i64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_end_i64_result)
db_end_i64_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx64_store_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - secondary

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, secondary=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.secondary = Uint64()
                    self.secondary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_store_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRUCT, 5)
            self.secondary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_store_args)
db_idx64_store_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRUCT, 'secondary', [Uint64, None], None, ),  # 5
)


class db_idx64_store_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_store_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_store_result)
db_idx64_store_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx64_update_args(object):
    """
    Attributes:
     - iterator
     - payer
     - secondary

    """


    def __init__(self, iterator=None, payer=None, secondary=None,):
        self.iterator = iterator
        self.payer = payer
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.secondary = Uint64()
                    self.secondary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_update_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRUCT, 3)
            self.secondary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_update_args)
db_idx64_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'secondary', [Uint64, None], None, ),  # 3
)


class db_idx64_update_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_update_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_update_result)
db_idx64_update_result.thrift_spec = (
)


class db_idx64_remove_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_remove_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_remove_args)
db_idx64_remove_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx64_remove_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_remove_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_remove_result)
db_idx64_remove_result.thrift_spec = (
)


class db_idx64_next_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_next_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_next_args)
db_idx64_next_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx64_next_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_next_result)
db_idx64_next_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx64_previous_args(object):
    """
    Attributes:
     - iteratory

    """


    def __init__(self, iteratory=None,):
        self.iteratory = iteratory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iteratory = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_previous_args')
        if self.iteratory is not None:
            oprot.writeFieldBegin('iteratory', TType.I32, 1)
            oprot.writeI32(self.iteratory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_previous_args)
db_idx64_previous_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iteratory', None, None, ),  # 1
)


class db_idx64_previous_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_previous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_previous_result)
db_idx64_previous_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx64_find_primary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_find_primary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 4)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_find_primary_args)
db_idx64_find_primary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 4
)


class db_idx64_find_primary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindPrimaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_find_primary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_find_primary_result)
db_idx64_find_primary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindPrimaryReturn, None], None, ),  # 0
)


class db_idx64_find_secondary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.secondary = Uint64()
                    self.secondary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_find_secondary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRUCT, 4)
            self.secondary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_find_secondary_args)
db_idx64_find_secondary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'secondary', [Uint64, None], None, ),  # 4
)


class db_idx64_find_secondary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSecondaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_find_secondary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_find_secondary_result)
db_idx64_find_secondary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindSecondaryReturn, None], None, ),  # 0
)


class db_idx64_lowerbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.secondary = Uint64()
                    self.secondary.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_lowerbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRUCT, 4)
            self.secondary.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_lowerbound_args)
db_idx64_lowerbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'secondary', [Uint64, None], None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx64_lowerbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_lowerbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_lowerbound_result)
db_idx64_lowerbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx64_upperbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.secondary = Uint64()
                    self.secondary.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_upperbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRUCT, 4)
            self.secondary.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_upperbound_args)
db_idx64_upperbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'secondary', [Uint64, None], None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx64_upperbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_upperbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_upperbound_result)
db_idx64_upperbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx64_end_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_end_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_end_args)
db_idx64_end_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_idx64_end_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx64_end_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx64_end_result)
db_idx64_end_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx128_store_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - secondary

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, secondary=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_store_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 5)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_store_args)
db_idx128_store_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRING, 'secondary', 'BINARY', None, ),  # 5
)


class db_idx128_store_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_store_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_store_result)
db_idx128_store_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx128_update_args(object):
    """
    Attributes:
     - iterator
     - payer
     - secondary

    """


    def __init__(self, iterator=None, payer=None, secondary=None,):
        self.iterator = iterator
        self.payer = payer
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_update_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 3)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_update_args)
db_idx128_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'secondary', 'BINARY', None, ),  # 3
)


class db_idx128_update_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_update_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_update_result)
db_idx128_update_result.thrift_spec = (
)


class db_idx128_remove_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_remove_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_remove_args)
db_idx128_remove_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx128_remove_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_remove_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_remove_result)
db_idx128_remove_result.thrift_spec = (
)


class db_idx128_next_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_next_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_next_args)
db_idx128_next_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx128_next_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_next_result)
db_idx128_next_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx128_previous_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_previous_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_previous_args)
db_idx128_previous_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx128_previous_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_previous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_previous_result)
db_idx128_previous_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx128_find_primary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_find_primary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 4)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_find_primary_args)
db_idx128_find_primary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 4
)


class db_idx128_find_primary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindPrimaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_find_primary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_find_primary_result)
db_idx128_find_primary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindPrimaryReturn, None], None, ),  # 0
)


class db_idx128_find_secondary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_find_secondary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_find_secondary_args)
db_idx128_find_secondary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
)


class db_idx128_find_secondary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSecondaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_find_secondary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_find_secondary_result)
db_idx128_find_secondary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindSecondaryReturn, None], None, ),  # 0
)


class db_idx128_lowerbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_lowerbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_lowerbound_args)
db_idx128_lowerbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx128_lowerbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_lowerbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_lowerbound_result)
db_idx128_lowerbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx128_upperbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_upperbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_upperbound_args)
db_idx128_upperbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx128_upperbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_upperbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_upperbound_result)
db_idx128_upperbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx128_end_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_end_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_end_args)
db_idx128_end_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_idx128_end_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx128_end_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx128_end_result)
db_idx128_end_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx256_store_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - data

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, data=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_store_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 5)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_store_args)
db_idx256_store_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRING, 'data', 'BINARY', None, ),  # 5
)


class db_idx256_store_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_store_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_store_result)
db_idx256_store_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx256_update_args(object):
    """
    Attributes:
     - iterator
     - payer
     - data

    """


    def __init__(self, iterator=None, payer=None, data=None,):
        self.iterator = iterator
        self.payer = payer
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_update_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_update_args)
db_idx256_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
)


class db_idx256_update_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_update_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_update_result)
db_idx256_update_result.thrift_spec = (
)


class db_idx256_remove_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_remove_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_remove_args)
db_idx256_remove_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx256_remove_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_remove_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_remove_result)
db_idx256_remove_result.thrift_spec = (
)


class db_idx256_next_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_next_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_next_args)
db_idx256_next_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx256_next_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_next_result)
db_idx256_next_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx256_previous_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_previous_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_previous_args)
db_idx256_previous_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx256_previous_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_previous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_previous_result)
db_idx256_previous_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx256_find_primary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_find_primary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 4)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_find_primary_args)
db_idx256_find_primary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 4
)


class db_idx256_find_primary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindPrimaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_find_primary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_find_primary_result)
db_idx256_find_primary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindPrimaryReturn, None], None, ),  # 0
)


class db_idx256_find_secondary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - data

    """


    def __init__(self, code=None, scope=None, table=None, data=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_find_secondary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 4)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_find_secondary_args)
db_idx256_find_secondary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'data', 'BINARY', None, ),  # 4
)


class db_idx256_find_secondary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSecondaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_find_secondary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_find_secondary_result)
db_idx256_find_secondary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindSecondaryReturn, None], None, ),  # 0
)


class db_idx256_lowerbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - data
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, data=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.data = data
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_lowerbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 4)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_lowerbound_args)
db_idx256_lowerbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'data', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx256_lowerbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_lowerbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_lowerbound_result)
db_idx256_lowerbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx256_upperbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - data
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, data=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.data = data
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_upperbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 4)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_upperbound_args)
db_idx256_upperbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'data', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx256_upperbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_upperbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_upperbound_result)
db_idx256_upperbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx256_end_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_end_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_end_args)
db_idx256_end_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_idx256_end_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx256_end_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx256_end_result)
db_idx256_end_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx_double_store_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - secondary

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, secondary=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_store_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 5)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_store_args)
db_idx_double_store_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRING, 'secondary', 'BINARY', None, ),  # 5
)


class db_idx_double_store_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_store_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_store_result)
db_idx_double_store_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx_double_update_args(object):
    """
    Attributes:
     - iterator
     - payer
     - secondary

    """


    def __init__(self, iterator=None, payer=None, secondary=None,):
        self.iterator = iterator
        self.payer = payer
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_update_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 3)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_update_args)
db_idx_double_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'secondary', 'BINARY', None, ),  # 3
)


class db_idx_double_update_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_update_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_update_result)
db_idx_double_update_result.thrift_spec = (
)


class db_idx_double_remove_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_remove_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_remove_args)
db_idx_double_remove_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_double_remove_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_remove_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_remove_result)
db_idx_double_remove_result.thrift_spec = (
)


class db_idx_double_next_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_next_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_next_args)
db_idx_double_next_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_double_next_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_next_result)
db_idx_double_next_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx_double_previous_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_previous_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_previous_args)
db_idx_double_previous_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_double_previous_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_previous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_previous_result)
db_idx_double_previous_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx_double_find_primary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_find_primary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 4)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_find_primary_args)
db_idx_double_find_primary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 4
)


class db_idx_double_find_primary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindPrimaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_find_primary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_find_primary_result)
db_idx_double_find_primary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindPrimaryReturn, None], None, ),  # 0
)


class db_idx_double_find_secondary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_find_secondary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_find_secondary_args)
db_idx_double_find_secondary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
)


class db_idx_double_find_secondary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSecondaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_find_secondary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_find_secondary_result)
db_idx_double_find_secondary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindSecondaryReturn, None], None, ),  # 0
)


class db_idx_double_lowerbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_lowerbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_lowerbound_args)
db_idx_double_lowerbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx_double_lowerbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_lowerbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_lowerbound_result)
db_idx_double_lowerbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx_double_upperbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_upperbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_upperbound_args)
db_idx_double_upperbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx_double_upperbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_upperbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_upperbound_result)
db_idx_double_upperbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx_double_end_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_end_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_end_args)
db_idx_double_end_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_idx_double_end_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_double_end_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_double_end_result)
db_idx_double_end_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx_long_double_store_args(object):
    """
    Attributes:
     - scope
     - table
     - payer
     - id
     - secondary

    """


    def __init__(self, scope=None, table=None, payer=None, id=None, secondary=None,):
        self.scope = scope
        self.table = table
        self.payer = payer
        self.id = id
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.id = Uint64()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_store_args')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 1)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 2)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 3)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 4)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 5)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_store_args)
db_idx_long_double_store_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'table', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'id', [Uint64, None], None, ),  # 4
    (5, TType.STRING, 'secondary', 'BINARY', None, ),  # 5
)


class db_idx_long_double_store_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_store_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_store_result)
db_idx_long_double_store_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class db_idx_long_double_update_args(object):
    """
    Attributes:
     - iterator
     - payer
     - secondary

    """


    def __init__(self, iterator=None, payer=None, secondary=None,):
        self.iterator = iterator
        self.payer = payer
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.payer = Uint64()
                    self.payer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_update_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        if self.payer is not None:
            oprot.writeFieldBegin('payer', TType.STRUCT, 2)
            self.payer.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 3)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_update_args)
db_idx_long_double_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
    (2, TType.STRUCT, 'payer', [Uint64, None], None, ),  # 2
    (3, TType.STRING, 'secondary', 'BINARY', None, ),  # 3
)


class db_idx_long_double_update_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_update_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_update_result)
db_idx_long_double_update_result.thrift_spec = (
)


class db_idx_long_double_remove_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_remove_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_remove_args)
db_idx_long_double_remove_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_long_double_remove_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_remove_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_remove_result)
db_idx_long_double_remove_result.thrift_spec = (
)


class db_idx_long_double_next_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_next_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_next_args)
db_idx_long_double_next_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_long_double_next_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_next_result)
db_idx_long_double_next_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx_long_double_previous_args(object):
    """
    Attributes:
     - iterator

    """


    def __init__(self, iterator=None,):
        self.iterator = iterator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.iterator = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_previous_args')
        if self.iterator is not None:
            oprot.writeFieldBegin('iterator', TType.I32, 1)
            oprot.writeI32(self.iterator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_previous_args)
db_idx_long_double_previous_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'iterator', None, None, ),  # 1
)


class db_idx_long_double_previous_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NextPreviousReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_previous_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_previous_result)
db_idx_long_double_previous_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NextPreviousReturn, None], None, ),  # 0
)


class db_idx_long_double_find_primary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_find_primary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 4)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_find_primary_args)
db_idx_long_double_find_primary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 4
)


class db_idx_long_double_find_primary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindPrimaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_find_primary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_find_primary_result)
db_idx_long_double_find_primary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindPrimaryReturn, None], None, ),  # 0
)


class db_idx_long_double_find_secondary_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_find_secondary_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_find_secondary_args)
db_idx_long_double_find_secondary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
)


class db_idx_long_double_find_secondary_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindSecondaryReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_find_secondary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_find_secondary_result)
db_idx_long_double_find_secondary_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindSecondaryReturn, None], None, ),  # 0
)


class db_idx_long_double_lowerbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_lowerbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_lowerbound_args)
db_idx_long_double_lowerbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx_long_double_lowerbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_lowerbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_lowerbound_result)
db_idx_long_double_lowerbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx_long_double_upperbound_args(object):
    """
    Attributes:
     - code
     - scope
     - table
     - secondary
     - primary

    """


    def __init__(self, code=None, scope=None, table=None, secondary=None, primary=None,):
        self.code = code
        self.scope = scope
        self.table = table
        self.secondary = secondary
        self.primary = primary

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.secondary = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.primary = Uint64()
                    self.primary.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_upperbound_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.secondary is not None:
            oprot.writeFieldBegin('secondary', TType.STRING, 4)
            oprot.writeBinary(self.secondary)
            oprot.writeFieldEnd()
        if self.primary is not None:
            oprot.writeFieldBegin('primary', TType.STRUCT, 5)
            self.primary.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_upperbound_args)
db_idx_long_double_upperbound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
    (4, TType.STRING, 'secondary', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'primary', [Uint64, None], None, ),  # 5
)


class db_idx_long_double_upperbound_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LowerBoundUpperBoundReturn()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_upperbound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_upperbound_result)
db_idx_long_double_upperbound_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [LowerBoundUpperBoundReturn, None], None, ),  # 0
)


class db_idx_long_double_end_args(object):
    """
    Attributes:
     - code
     - scope
     - table

    """


    def __init__(self, code=None, scope=None, table=None,):
        self.code = code
        self.scope = scope
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.code = Uint64()
                    self.code.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.scope = Uint64()
                    self.scope.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table = Uint64()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_end_args')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.STRUCT, 1)
            self.code.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRUCT, 2)
            self.scope.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 3)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_end_args)
db_idx_long_double_end_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'code', [Uint64, None], None, ),  # 1
    (2, TType.STRUCT, 'scope', [Uint64, None], None, ),  # 2
    (3, TType.STRUCT, 'table', [Uint64, None], None, ),  # 3
)


class db_idx_long_double_end_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('db_idx_long_double_end_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(db_idx_long_double_end_result)
db_idx_long_double_end_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_action_return_value_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_action_return_value_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_action_return_value_args)
set_action_return_value_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)


class set_action_return_value_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_action_return_value_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_action_return_value_result)
set_action_return_value_result.thrift_spec = (
)


class get_code_hash_args(object):
    """
    Attributes:
     - account
     - struct_version

    """


    def __init__(self, account=None, struct_version=None,):
        self.account = account
        self.struct_version = struct_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.account = Uint64()
                    self.account.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.struct_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_code_hash_args')
        if self.account is not None:
            oprot.writeFieldBegin('account', TType.STRUCT, 1)
            self.account.write(oprot)
            oprot.writeFieldEnd()
        if self.struct_version is not None:
            oprot.writeFieldBegin('struct_version', TType.I64, 2)
            oprot.writeI64(self.struct_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_code_hash_args)
get_code_hash_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'account', [Uint64, None], None, ),  # 1
    (2, TType.I64, 'struct_version', None, None, ),  # 2
)


class get_code_hash_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_code_hash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_code_hash_result)
get_code_hash_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class get_block_num_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_block_num_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_block_num_args)
get_block_num_args.thrift_spec = (
)


class get_block_num_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_block_num_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_block_num_result)
get_block_num_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class sha3_args(object):
    """
    Attributes:
     - data
     - keccak

    """


    def __init__(self, data=None, keccak=None,):
        self.data = data
        self.keccak = keccak

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.keccak = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha3_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.keccak is not None:
            oprot.writeFieldBegin('keccak', TType.I32, 2)
            oprot.writeI32(self.keccak)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha3_args)
sha3_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
    (2, TType.I32, 'keccak', None, None, ),  # 2
)


class sha3_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sha3_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sha3_result)
sha3_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class blake2_f_args(object):
    """
    Attributes:
     - rounds
     - state
     - msg
     - t0_offset
     - t1_offset
     - final

    """


    def __init__(self, rounds=None, state=None, msg=None, t0_offset=None, t1_offset=None, final=None,):
        self.rounds = rounds
        self.state = state
        self.msg = msg
        self.t0_offset = t0_offset
        self.t1_offset = t1_offset
        self.final = final

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.rounds = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.state = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.msg = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.t0_offset = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.t1_offset = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.final = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('blake2_f_args')
        if self.rounds is not None:
            oprot.writeFieldBegin('rounds', TType.I64, 1)
            oprot.writeI64(self.rounds)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRING, 2)
            oprot.writeBinary(self.state)
            oprot.writeFieldEnd()
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRING, 3)
            oprot.writeBinary(self.msg)
            oprot.writeFieldEnd()
        if self.t0_offset is not None:
            oprot.writeFieldBegin('t0_offset', TType.STRING, 4)
            oprot.writeBinary(self.t0_offset)
            oprot.writeFieldEnd()
        if self.t1_offset is not None:
            oprot.writeFieldBegin('t1_offset', TType.STRING, 5)
            oprot.writeBinary(self.t1_offset)
            oprot.writeFieldEnd()
        if self.final is not None:
            oprot.writeFieldBegin('final', TType.I32, 6)
            oprot.writeI32(self.final)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(blake2_f_args)
blake2_f_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'rounds', None, None, ),  # 1
    (2, TType.STRING, 'state', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'msg', 'BINARY', None, ),  # 3
    (4, TType.STRING, 't0_offset', 'BINARY', None, ),  # 4
    (5, TType.STRING, 't1_offset', 'BINARY', None, ),  # 5
    (6, TType.I32, 'final', None, None, ),  # 6
)


class blake2_f_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('blake2_f_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(blake2_f_result)
blake2_f_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class k1_recover_args(object):
    """
    Attributes:
     - sig
     - dig

    """


    def __init__(self, sig=None, dig=None,):
        self.sig = sig
        self.dig = dig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sig = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dig = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('k1_recover_args')
        if self.sig is not None:
            oprot.writeFieldBegin('sig', TType.STRING, 1)
            oprot.writeBinary(self.sig)
            oprot.writeFieldEnd()
        if self.dig is not None:
            oprot.writeFieldBegin('dig', TType.STRING, 2)
            oprot.writeBinary(self.dig)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(k1_recover_args)
k1_recover_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sig', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'dig', 'BINARY', None, ),  # 2
)


class k1_recover_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('k1_recover_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(k1_recover_result)
k1_recover_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class alt_bn128_add_args(object):
    """
    Attributes:
     - op1
     - op2

    """


    def __init__(self, op1=None, op2=None,):
        self.op1 = op1
        self.op2 = op2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.op1 = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.op2 = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_add_args')
        if self.op1 is not None:
            oprot.writeFieldBegin('op1', TType.STRING, 1)
            oprot.writeBinary(self.op1)
            oprot.writeFieldEnd()
        if self.op2 is not None:
            oprot.writeFieldBegin('op2', TType.STRING, 2)
            oprot.writeBinary(self.op2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_add_args)
alt_bn128_add_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'op1', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'op2', 'BINARY', None, ),  # 2
)


class alt_bn128_add_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_add_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_add_result)
alt_bn128_add_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class alt_bn128_mul_args(object):
    """
    Attributes:
     - g1
     - scalar

    """


    def __init__(self, g1=None, scalar=None,):
        self.g1 = g1
        self.scalar = scalar

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.g1 = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.scalar = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_mul_args')
        if self.g1 is not None:
            oprot.writeFieldBegin('g1', TType.STRING, 1)
            oprot.writeBinary(self.g1)
            oprot.writeFieldEnd()
        if self.scalar is not None:
            oprot.writeFieldBegin('scalar', TType.STRING, 2)
            oprot.writeBinary(self.scalar)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_mul_args)
alt_bn128_mul_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'g1', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'scalar', 'BINARY', None, ),  # 2
)


class alt_bn128_mul_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_mul_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_mul_result)
alt_bn128_mul_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class alt_bn128_pair_args(object):
    """
    Attributes:
     - pairs

    """


    def __init__(self, pairs=None,):
        self.pairs = pairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pairs = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_pair_args')
        if self.pairs is not None:
            oprot.writeFieldBegin('pairs', TType.STRING, 1)
            oprot.writeBinary(self.pairs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_pair_args)
alt_bn128_pair_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pairs', 'BINARY', None, ),  # 1
)


class alt_bn128_pair_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('alt_bn128_pair_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(alt_bn128_pair_result)
alt_bn128_pair_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class mod_exp_args(object):
    """
    Attributes:
     - base
     - exp
     - mod

    """


    def __init__(self, base=None, exp=None, mod=None,):
        self.base = base
        self.exp = exp
        self.mod = mod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.base = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.exp = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mod = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mod_exp_args')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRING, 1)
            oprot.writeBinary(self.base)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRING, 2)
            oprot.writeBinary(self.exp)
            oprot.writeFieldEnd()
        if self.mod is not None:
            oprot.writeFieldBegin('mod', TType.STRING, 3)
            oprot.writeBinary(self.mod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mod_exp_args)
mod_exp_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'base', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'exp', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'mod', 'BINARY', None, ),  # 3
)


class mod_exp_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mod_exp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mod_exp_result)
mod_exp_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)
fix_spec(all_structs)
del all_structs
